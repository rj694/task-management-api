### File: C:\Users\rdjon\task-management-api\all_code_dump.txt


### File: C:\Users\rdjon\task-management-api\config.py
"""Application configuration."""
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Flask settings
FLASK_APP = os.getenv('FLASK_APP', 'run.py')
FLASK_ENV = os.getenv('FLASK_ENV', 'development')

### File: C:\Users\rdjon\task-management-api\database_schema.txt
Task Management API Database Schema
===================================

User
----
id: Integer (Primary Key)
username: String(80) (Unique, Not Null)
email: String(120) (Unique, Not Null)
password_hash: String(256) (Not Null)
created_at: DateTime
updated_at: DateTime

Relationships:
- tasks: One-to-Many relationship with Task

Task
----
id: Integer (Primary Key)
title: String(100) (Not Null)
description: Text
status: String(20) (Default: 'pending')
priority: String(20) (Default: 'medium')
due_date: DateTime
created_at: DateTime
updated_at: DateTime
user_id: Integer (Foreign Key -> User.id, Not Null)

Relationships:
- user: Many-to-One relationship with User

### File: C:\Users\rdjon\task-management-api\dump_all_code.py
import os

# -------------------------------------------------------------------
# CONFIGURATION
# -------------------------------------------------------------------

# Absolute path to the directory you want to dump
ROOT_DIR = r"C:\Users\rdjon\task-management-api"

# Output file
OUTPUT_FILE = os.path.join(ROOT_DIR, "all_code_dump.txt")

# Directory names to skip entirely
EXCLUDE_DIRS = {
    "__pycache__",
    ".pytest_cache",
    "venv",
    "coverage_reports",
    "node_modules",    # Added to exclude node_modules
    "build",           # Added to exclude build directory
    "dist",            # Added to exclude dist directory
    ".git",            # Added to exclude .git
    ".idea",           # Added to exclude .idea
}

# File extensions to dump (only text–based). Added frontend file extensions.
INCLUDE_EXTS = {
    # Backend
    ".py", ".txt", ".md", ".cfg", ".ini", ".yml", ".yaml", ".json",
    ".env",
    # Frontend
    ".js", ".jsx", ".ts", ".tsx", ".html", ".css", ".scss", ".sass",
    ".vue", ".svelte", ".less"
}

# -------------------------------------------------------------------
# FUNCTIONS
# -------------------------------------------------------------------

def is_binary_file(filepath):
    """
    Heuristic check for binary files: looks for null bytes
    in the first 1 KB. If any are found, treat as binary.
    """
    try:
        with open(filepath, 'rb') as f:
            chunk = f.read(1024)
        return b'\0' in chunk
    except Exception:
        # if we can't even read it in binary mode, skip it
        return True

def should_include_file(filepath):
    """
    Decide whether to include this file.
    - Must have one of the allowed extensions.
    - Must not look binary.
    """
    _, ext = os.path.splitext(filepath)
    if ext.lower() not in INCLUDE_EXTS:
        return False
    return not is_binary_file(filepath)

def dump_code(root_dir, output_filepath):
    """
    Walk root_dir, skip any directories in EXCLUDE_DIRS,
    and append each file's contents (with headers) to output_filepath.
    """
    with open(output_filepath, 'w', encoding='utf-8') as out:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # remove excluded directories in-place so os.walk will skip them
            dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]

            for fname in filenames:
                fpath = os.path.join(dirpath, fname)
                if not should_include_file(fpath):
                    continue

                try:
                    with open(fpath, 'r', encoding='utf-8', errors='ignore') as f:
                        out.write(f"### File: {fpath}\n")
                        out.write(f.read())
                        out.write("\n\n")
                except Exception as e:
                    print(f"⚠️ Could not read {fpath!r}: {e}")

if __name__ == "__main__":
    dump_code(ROOT_DIR, OUTPUT_FILE)
    print(f"✅ All code dumped to {OUTPUT_FILE!r}")

### File: C:\Users\rdjon\task-management-api\jwt_debug.py
from app import create_app
from flask_jwt_extended import create_access_token, decode_token, get_jwt_identity
from flask import current_app
import os

def debug_jwt():
    """Debug JWT token generation and verification."""
    app = create_app()
    
    with app.app_context():
        # Print environment variables and configuration
        print("=== ENVIRONMENT VARIABLES ===")
        print(f"JWT_SECRET_KEY from env: '{os.environ.get('JWT_SECRET_KEY')}'")
        print(f"SECRET_KEY from env: '{os.environ.get('SECRET_KEY')}'")
        
        print("\n=== FLASK CONFIG ===")
        print(f"JWT_SECRET_KEY from config: '{app.config.get('JWT_SECRET_KEY')}'")
        print(f"JWT_ALGORITHM from config: '{app.config.get('JWT_ALGORITHM')}'")
        print(f"JWT_HEADER_TYPE from config: '{app.config.get('JWT_HEADER_TYPE')}'")
        print(f"JWT_TOKEN_LOCATION from config: '{app.config.get('JWT_TOKEN_LOCATION')}'")
        
        # Generate a token with string identity
        print("\n=== GENERATING TOKEN WITH STRING IDENTITY ===")
        user_id = 1
        access_token = create_access_token(identity=str(user_id))
        print(f"Generated token: {access_token}")
        
        # Try to decode the token
        print("\n=== DECODING TOKEN ===")
        try:
            decoded_token = decode_token(access_token)
            print(f"Successfully decoded token: {decoded_token}")
            
            # Extract identity
            print(f"Identity from token: {decoded_token.get('sub')}")
        except Exception as e:
            print(f"Failed to decode token: {str(e)}")

if __name__ == "__main__":
    debug_jwt()

### File: C:\Users\rdjon\task-management-api\pytest.ini
[pytest]
testpaths = tests
python_files = test_*.py
python_functions = test_*
python_classes = Test*
filterwarnings =
    ignore::DeprecationWarning
    ignore::UserWarning
addopts = -v

### File: C:\Users\rdjon\task-management-api\README.md
# Task Management API

A RESTful API for managing tasks, built with Flask.

## Features

- User registration and authentication using JWT
- CRUD operations for tasks
- Filtering, sorting, and pagination of tasks
- Search functionality
- Bulk operations for tasks
- Task statistics
- Comprehensive test coverage
- API documentation with Swagger

## Requirements

- Python 3.8+
- PostgreSQL

## Installation

1. Clone the repository:
git clone https://github.com/yourusername/task-management-api.git
cd task-management-api

2. Create a virtual environment and install dependencies:
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install -r requirements.txt

3. Set up environment variables:
cp .env.example .env
Edit the `.env` file to configure your database connection and other settings.

4. Create the database:
createdb task_management

5. Run database migrations:
flask db upgrade

## Running the Application
flask run

The API will be available at http://localhost:5000

## API Documentation

Swagger UI will be available at http://localhost:5000/api/docs when the project is completed.

## Running Tests
pytest

## License

MIT

### File: C:\Users\rdjon\task-management-api\requirements.txt
absl-py==1.4.0
aiohttp==3.9.0
aiosignal==1.3.1
alembic==1.15.2
aniso8601==10.0.1
annotated-types==0.6.0
antlr4-python3-runtime==4.9.3
anyio==3.7.1
argon2-cffi==23.1.0
argon2-cffi-bindings==21.2.0
arrow==1.2.3
asgiref==3.7.2
asttokens==2.4.0
astunparse==1.6.3
async-lru==2.0.4
attrs==23.1.0
Babel==2.12.1
backcall==0.2.0
beautifulsoup4==4.12.2
black==23.12.1
bleach==6.0.0
blinker==1.7.0
cachetools==5.3.1
certifi==2023.7.22
cffi==1.15.1
charset-normalizer==3.2.0
click==8.1.7
cloudpickle==3.0.0
colorama==0.4.6
comm==0.1.4
contourpy==1.1.1
coverage==7.8.0
cycler==0.11.0
debugpy==1.8.0
decorator==5.1.1
defusedxml==0.7.1
Deprecated==1.2.18
detectron2 @ git+https://github.com/facebookresearch/detectron2.git@864913f0e57e87a75c8cc0c7d79ecbd774fc669b
distro==1.8.0
Django==4.2.7
et-xmlfile==1.1.0
executing==1.2.0
fastjsonschema==2.18.0
filelock==3.13.1
Flask==3.0.0
flask-cors==5.0.1
Flask-JWT-Extended==4.7.1
Flask-Limiter==3.12
Flask-Mail==0.10.0
Flask-Migrate==4.1.0
Flask-RESTful==0.3.10
Flask-SQLAlchemy==3.1.1
flask-swagger-ui==4.11.1
flatbuffers==23.5.26
fonttools==4.42.1
fqdn==1.5.1
frozenlist==1.4.0
fsspec==2023.12.2
fvcore==0.1.5.post20221221
gast==0.4.0
google-auth==2.23.0
google-auth-oauthlib==1.0.0
google-pasta==0.2.0
graphviz==0.20.3
greenlet==3.2.1
grpcio==1.58.0
gunicorn==23.0.0
h11==0.14.0
h5py==3.9.0
httpcore==1.0.2
httpx==0.25.1
hydra-core==1.3.2
idna==3.4
image==1.5.33
iniconfig==2.1.0
iopath==0.1.9
ipykernel==6.25.2
ipython==8.15.0
isoduration==20.11.0
itsdangerous==2.1.2
jedi==0.19.0
Jinja2==3.1.2
joblib==1.4.2
json5==0.9.14
jsonpointer==2.4
jsonschema==4.19.0
jsonschema-specifications==2023.7.1
jupyter-events==0.7.0
jupyter-lsp==2.2.0
jupyter_client==8.3.1
jupyter_core==5.3.1
jupyter_server==2.7.3
jupyter_server_terminals==0.4.4
jupyterlab==4.0.6
jupyterlab-pygments==0.2.2
jupyterlab_server==2.25.0
keras==2.13.1
kiwisolver==1.4.5
libclang==16.0.6
limits==5.1.0
lxml==4.9.3
Mako==1.3.10
Markdown==3.4.4
markdown-it-py==3.0.0
MarkupSafe==2.1.3
marshmallow==4.0.0
matplotlib==3.8.0
matplotlib-inline==0.1.6
mdurl==0.1.2
mistune==3.0.1
mpmath==1.3.0
multidict==6.0.4
mypy-extensions==1.0.0
nbclient==0.8.0
nbconvert==7.8.0
nbformat==5.9.2
nest-asyncio==1.5.8
networkx==3.2.1
notebook==7.0.3
notebook_shim==0.2.3
numpy==1.24.3
oauthlib==3.2.2
omegaconf==2.3.0
openai==1.3.5
opencv-python==4.9.0.80
openpyxl==3.1.2
opt-einsum==3.3.0
ordered-set==4.1.0
overrides==7.4.0
packaging==23.1
pandas==2.1.2
pandocfilters==1.5.0
parso==0.8.3
pathspec==0.12.1
pickleshare==0.7.5
Pillow==10.0.1
platformdirs==3.10.0
pluggy==1.5.0
portalocker==2.8.2
prometheus-client==0.17.1
prompt-toolkit==3.0.39
protobuf==4.24.3
psutil==5.9.5
psycopg2-binary==2.9.10
pure-eval==0.2.2
pyasn1==0.5.0
pyasn1-modules==0.3.0
PyAudio==0.2.14
pycocotools==2.0.7
pycparser==2.21
pydantic==2.5.2
pydantic_core==2.14.5
pydot==3.0.2
pydub==0.25.1
Pygments==2.16.1
PyJWT==2.10.1
pyparsing==3.1.1
PyQt6==6.6.0
PyQt6-Qt6==6.6.0
PyQt6-sip==13.6.0
pytest==8.3.5
pytest-cov==6.1.1
python-dateutil==2.8.2
python-docx==1.1.0
python-dotenv==1.1.0
python-json-logger==2.0.7
pytz==2023.3.post1
pywin32==306
pywinpty==2.0.11
PyYAML==6.0.1
pyzmq==25.1.1
referencing==0.30.2
requests==2.31.0
requests-oauthlib==1.3.1
rfc3339-validator==0.1.4
rfc3986-validator==0.1.1
rich==13.9.4
rpds-py==0.10.3
rsa==4.9
scikit-learn==1.5.2
scipy==1.14.1
seaborn==0.13.2
Send2Trash==1.8.2
simpleaudio==1.0.4
six==1.16.0
sniffio==1.3.0
sounddevice==0.4.6
soupsieve==2.5
SQLAlchemy==2.0.40
sqlparse==0.4.4
stack-data==0.6.2
sympy==1.12
tabulate==0.9.0
tensorboard==2.13.0
tensorboard-data-server==0.7.1
tensorflow==2.13.0
tensorflow-estimator==2.13.0
tensorflow-intel==2.13.0
tensorflow-io-gcs-filesystem==0.31.0
termcolor==2.3.0
terminado==0.17.1
threadpoolctl==3.5.0
tinycss2==1.2.1
torch==2.1.2
torchaudio==2.1.2
torchvision==0.16.2
tornado==6.3.3
tqdm==4.66.1
traitlets==5.10.0
treelib==1.7.0
typing_extensions==4.13.2
tzdata==2023.3
uri-template==1.3.0
urllib3==1.26.16
wavio==0.0.8
wcwidth==0.2.6
webcolors==1.13
webencodings==0.5.1
websocket-client==1.6.3
Werkzeug==3.0.1
wrapt==1.15.0
yacs==0.1.8
yarl==1.9.3


### File: C:\Users\rdjon\task-management-api\run.py
from dotenv import load_dotenv
load_dotenv()

from app import create_app, db
from app.models.user import User
from app.models.task import Task
from flask_migrate import Migrate

app = create_app()
migrate = Migrate(app, db)

# Create shell context
@app.shell_context_processor
def make_shell_context():
    """Create shell context for Flask CLI."""
    return {
        'db': db,
        'User': User,
        'Task': Task
    }

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)

### File: C:\Users\rdjon\task-management-api\run_tests.py
import subprocess
import os
import sys

def run_tests():
    """Run tests with coverage."""
    print("=== Running Tests with Coverage ===")
    
    # Create a directory for coverage reports
    if not os.path.exists('coverage_reports'):
        os.makedirs('coverage_reports')
    
    # Run tests with coverage
    try:
        result = subprocess.run([
            'pytest', 
            '--cov=app', 
            '--cov-report=term', 
            '--cov-report=html:coverage_reports/html',
            '--cov-report=xml:coverage_reports/coverage.xml',
            'tests/'
        ], check=True)
        
        print("\n=== Tests completed successfully! ===")
        return 0
    except subprocess.CalledProcessError as e:
        print(f"\n=== Tests failed with exit code {e.returncode} ===")
        return e.returncode

if __name__ == "__main__":
    sys.exit(run_tests())

### File: C:\Users\rdjon\task-management-api\test_advanced_features.py
import requests
import json
from pprint import pprint

BASE_URL = "http://localhost:5000/api/v1"

def test_tag_operations(auth_token):
    """Test tag operations."""
    print("=== Testing Tag Operations ===")
    
    headers = {
        "Authorisation": f"Bearer {auth_token}",
        "Content-Type": "application/json"
    }
    
    # Create a tag
    print("\n1. Creating a tag...")
    tag_data = {
        "name": "Important",
        "color": "#ff0000"
    }
    
    create_tag_response = requests.post(f"{BASE_URL}/tags", json=tag_data, headers=headers)
    print(f"Status code: {create_tag_response.status_code}")
    
    if create_tag_response.status_code != 201:
        print("Failed to create tag!")
        return None
    
    tag = create_tag_response.json()['tag']
    tag_id = tag['id']
    print(f"Created tag with ID: {tag_id}")
    
    # Get all tags
    print("\n2. Getting all tags...")
    get_tags_response = requests.get(f"{BASE_URL}/tags", headers=headers)
    print(f"Status code: {get_tags_response.status_code}")
    
    if get_tags_response.status_code == 200:
        tags = get_tags_response.json()
        print(f"Found {len(tags)} tags:")
        for tag in tags:
            print(f"  - {tag['name']} (ID: {tag['id']})")
    
    # Update the tag
    print("\n3. Updating a tag...")
    update_tag_data = {
        "name": "Very Important",
        "color": "#ff5500"
    }
    
    update_tag_response = requests.put(f"{BASE_URL}/tags/{tag_id}", json=update_tag_data, headers=headers)
    print(f"Status code: {update_tag_response.status_code}")
    
    if update_tag_response.status_code == 200:
        updated_tag = update_tag_response.json()['tag']
        print(f"Updated tag: {updated_tag['name']} (Color: {updated_tag['color']})")
    
    return tag_id

def test_task_with_tags(auth_token, tag_id):
    """Test task operations with tags."""
    print("\n=== Testing Tasks with Tags ===")
    
    headers = {
        "Authorisation": f"Bearer {auth_token}",
        "Content-Type": "application/json"
    }
    
    # Create a task with a tag
    print("\n1. Creating a task with a tag...")
    task_data = {
        "title": "Important Task",
        "description": "This is a very important task",
        "status": "pending",
        "priority": "high",
        "tag_ids": [tag_id]
    }
    
    create_task_response = requests.post(f"{BASE_URL}/tasks", json=task_data, headers=headers)
    print(f"Status code: {create_task_response.status_code}")
    
    if create_task_response.status_code != 201:
        print("Failed to create task!")
        return None
    
    task = create_task_response.json()['task']
    task_id = task['id']
    print(f"Created task with ID: {task_id}")
    
    # Get task with tags
    print("\n2. Getting task with tags...")
    get_task_response = requests.get(f"{BASE_URL}/tasks/{task_id}", headers=headers)
    print(f"Status code: {get_task_response.status_code}")
    
    if get_task_response.status_code == 200:
        task_with_tags = get_task_response.json()
        print(f"Task: {task_with_tags['title']}")
        print(f"Tags: {len(task_with_tags['tags'])}")
        for tag in task_with_tags['tags']:
            print(f"  - {tag['name']} (Color: {tag['color']})")
    
    # Filter tasks by tag
    print("\n3. Filtering tasks by tag...")
    get_filtered_tasks_response = requests.get(f"{BASE_URL}/tasks?tag={tag_id}", headers=headers)
    print(f"Status code: {get_filtered_tasks_response.status_code}")
    
    if get_filtered_tasks_response.status_code == 200:
        filtered_tasks = get_filtered_tasks_response.json()
        print(f"Found {filtered_tasks['total']} tasks with tag ID {tag_id}")
    
    return task_id

def test_task_comments(auth_token, task_id):
    """Test task comments."""
    print("\n=== Testing Task Comments ===")
    
    headers = {
        "Authorisation": f"Bearer {auth_token}",
        "Content-Type": "application/json"
    }
    
    # Add a comment to a task
    print("\n1. Adding a comment to a task...")
    comment_data = {
        "content": "This is a very important comment on this task!"
    }
    
    create_comment_response = requests.post(f"{BASE_URL}/tasks/{task_id}/comments", json=comment_data, headers=headers)
    print(f"Status code: {create_comment_response.status_code}")
    
    if create_comment_response.status_code != 201:
        print("Failed to create comment!")
        return None
    
    comment = create_comment_response.json()['comment']
    comment_id = comment['id']
    print(f"Created comment with ID: {comment_id}")
    
    # Get all comments for a task
    print("\n2. Getting all comments for a task...")
    get_comments_response = requests.get(f"{BASE_URL}/tasks/{task_id}/comments", headers=headers)
    print(f"Status code: {get_comments_response.status_code}")
    
    if get_comments_response.status_code == 200:
        comments = get_comments_response.json()
        print(f"Found {len(comments)} comments:")
        for comment in comments:
            print(f"  - {comment['content']}")
    
    # Update a comment
    print("\n3. Updating a comment...")
    update_comment_data = {
        "content": "This is an updated comment!"
    }
    
    update_comment_response = requests.put(f"{BASE_URL}/comments/{comment_id}", json=update_comment_data, headers=headers)
    print(f"Status code: {update_comment_response.status_code}")
    
    if update_comment_response.status_code == 200:
        updated_comment = update_comment_response.json()['comment']
        print(f"Updated comment: {updated_comment['content']}")
    
    return comment_id

def test_task_export(auth_token):
    """Test task export functionality."""
    print("\n=== Testing Task Export ===")
    
    headers = {
        "Authorisation": f"Bearer {auth_token}"
    }
    
    # Export tasks as JSON
    print("\n1. Exporting tasks as JSON...")
    export_json_response = requests.get(f"{BASE_URL}/tasks/export?format=json", headers=headers)
    print(f"Status code: {export_json_response.status_code}")
    
    if export_json_response.status_code == 200:
        tasks = export_json_response.json()
        print(f"Exported {len(tasks)} tasks in JSON format")
    
    # Export tasks as CSV
    print("\n2. Exporting tasks as CSV...")
    export_csv_response = requests.get(f"{BASE_URL}/tasks/export?format=csv", headers=headers)
    print(f"Status code: {export_csv_response.status_code}")
    
    if export_csv_response.status_code == 200:
        content_disposition = export_csv_response.headers.get('Content-Disposition')
        content_type = export_csv_response.headers.get('Content-Type')
        print(f"Exported tasks in CSV format (Content-Type: {content_type})")
        print(f"Content-Disposition: {content_disposition}")
        
        # Save CSV file locally
        with open("tasks_export.csv", "w") as f:
            f.write(export_csv_response.text)
        print("Saved exported CSV to tasks_export.csv")

def test_rate_limiting(auth_token):
    """Test rate limiting."""
    print("\n=== Testing Rate Limiting ===")
    
    headers = {
        "Authorisation": f"Bearer {auth_token}",
        "Content-Type": "application/json"
    }
    
    # Perform multiple requests to trigger rate limiting
    print("\n1. Making multiple requests to test rate limiting...")
    endpoint = f"{BASE_URL}/tasks"
    
    for i in range(1, 6):
        print(f"Request {i}...")
        response = requests.get(endpoint, headers=headers)
        print(f"Status code: {response.status_code}")
        
        # Check for rate limit headers
        remaining = response.headers.get('X-RateLimit-Remaining')
        limit = response.headers.get('X-RateLimit-Limit')
        reset = response.headers.get('X-RateLimit-Reset')
        
        if remaining and limit and reset:
            print(f"Rate limit: {remaining}/{limit} requests remaining, resets in {reset}s")

def run_tests():
    """Run all tests."""
    print("=== Testing Advanced Features ===")
    
    # Login to get an access token
    print("\nLogging in to get an access token...")
    login_data = {
        "email": "test@example.com",
        "password": "password123"
    }
    
    login_response = requests.post(f"{BASE_URL}/auth/login", json=login_data)
    print(f"Status code: {login_response.status_code}")
    
    if login_response.status_code != 200:
        print("Login failed!")
        return
    
    auth_token = login_response.json()['access_token']
    
    # Test tag operations
    tag_id = test_tag_operations(auth_token)
    
    if tag_id:
        # Test task with tags
        task_id = test_task_with_tags(auth_token, tag_id)
        
        if task_id:
            # Test task comments
            comment_id = test_task_comments(auth_token, task_id)
            
            # Test task export
            test_task_export(auth_token)
    
    # Test rate limiting
    test_rate_limiting(auth_token)
    
    print("\n=== All Tests Completed ===")

if __name__ == "__main__":
    run_tests()

### File: C:\Users\rdjon\task-management-api\test_api.py
import requests
import json
from pprint import pprint

BASE_URL = "http://localhost:5000/api/v1"

def test_register():
    """Test user registration."""
    print("Testing user registration...")
    
    data = {
        "username": "testuser",
        "email": "test@example.com",
        "password": "password123"
    }
    
    response = requests.post(f"{BASE_URL}/auth/register", json=data)
    
    print(f"Status code: {response.status_code}")
    pprint(response.json())
    
    return response.json()

def test_login():
    """Test user login."""
    print("\nTesting user login...")
    
    data = {
        "email": "test@example.com",
        "password": "password123"
    }
    
    response = requests.post(f"{BASE_URL}/auth/login", json=data)
    
    print(f"Status code: {response.status_code}")
    pprint(response.json())
    
    return response.json()

def test_create_task(access_token):
    """Test task creation."""
    print("\nTesting task creation...")
    print(f"Using token: {access_token[:20]}...")
    
    # Make sure the header format is exactly 'Bearer <token>' with a space
    headers = {
        "Authorisation": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }
    
    data = {
        "title": "Test Task",
        "description": "This is a test task",
        "status": "pending",
        "priority": "high"
    }
    
    response = requests.post(f"{BASE_URL}/tasks", json=data, headers=headers)
    
    print(f"Status code: {response.status_code}")
    if response.status_code == 401:
        print("DEBUG: Authorisation header sent:", headers["Authorisation"])
    pprint(response.json())
    
    return response.json()

def test_get_tasks(access_token):
    """Test getting all tasks."""
    print("\nTesting get all tasks...")
    
    headers = {
        "Authorisation": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }
    
    response = requests.get(f"{BASE_URL}/tasks", headers=headers)
    
    print(f"Status code: {response.status_code}")
    pprint(response.json())
    
    return response.json()

def test_get_task(access_token, task_id):
    """Test getting a specific task."""
    print(f"\nTesting get task {task_id}...")
    
    headers = {
        "Authorisation": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }
    
    response = requests.get(f"{BASE_URL}/tasks/{task_id}", headers=headers)
    
    print(f"Status code: {response.status_code}")
    pprint(response.json())
    
    return response.json()

def test_update_task(access_token, task_id):
    """Test updating a task."""
    print(f"\nTesting update task {task_id}...")
    
    headers = {
        "Authorisation": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }
    
    data = {
        "title": "Updated Test Task",
        "status": "in_progress"
    }
    
    response = requests.put(f"{BASE_URL}/tasks/{task_id}", json=data, headers=headers)
    
    print(f"Status code: {response.status_code}")
    pprint(response.json())
    
    return response.json()

def test_task_statistics(access_token):
    """Test getting task statistics."""
    print("\nTesting task statistics...")
    
    headers = {
        "Authorisation": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }
    
    response = requests.get(f"{BASE_URL}/tasks/statistics", headers=headers)
    
    print(f"Status code: {response.status_code}")
    pprint(response.json())
    
    return response.json()

def test_delete_task(access_token, task_id):
    """Test deleting a task."""
    print(f"\nTesting delete task {task_id}...")
    
    headers = {
        "Authorisation": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }
    
    response = requests.delete(f"{BASE_URL}/tasks/{task_id}", headers=headers)
    
    print(f"Status code: {response.status_code}")
    pprint(response.json())
    
    return response.json()

def run_tests():
    """Run all tests."""
    try:
        # Register a new user
        register_data = test_register()
        
        # Login
        login_data = test_login()
        access_token = login_data.get('access_token')
        
        if not access_token:
            print("Failed to get access token!")
            return
        
        # Create a task
        task_data = test_create_task(access_token)
        
        # Check if task creation was successful
        if 'task' not in task_data:
            print("Task creation failed!")
            return
            
        task_id = task_data['task']['id']
        
        # Get all tasks
        test_get_tasks(access_token)
        
        # Get a specific task
        test_get_task(access_token, task_id)
        
        # Update a task
        test_update_task(access_token, task_id)
        
        # Get task statistics
        test_task_statistics(access_token)
        
        # Delete a task
        test_delete_task(access_token, task_id)
        
        print("\nAll tests completed!")
    except Exception as e:
        print(f"Test error: {str(e)}")

if __name__ == "__main__":
    run_tests()

### File: C:\Users\rdjon\task-management-api\test_auth_features.py
import requests
import json
from pprint import pprint

BASE_URL = "http://localhost:5000/api/v1"

def test_register_login_logout():
    """Test the complete authentication flow."""
    # Register a new user
    print("1. Registering a new user...")
    register_data = {
        "username": "testuser2",
        "email": "test2@example.com",
        "password": "password123"
    }
    
    register_response = requests.post(f"{BASE_URL}/auth/register", json=register_data)
    print(f"Status code: {register_response.status_code}")
    
    if register_response.status_code != 201:
        login_data = {
            "email": "test2@example.com",
            "password": "password123"
        }
        print("\nUser might already exist. Trying to login...")
        login_response = requests.post(f"{BASE_URL}/auth/login", json=login_data)
        if login_response.status_code != 200:
            print(f"Login failed with status code: {login_response.status_code}")
            return
        tokens = login_response.json()
    else:
        tokens = register_response.json()
    
    access_token = tokens.get('access_token')
    refresh_token = tokens.get('refresh_token')
    
    # Get user profile
    print("\n2. Getting user profile...")
    headers = {
        "Authorisation": f"Bearer {access_token}"
    }
    
    profile_response = requests.get(f"{BASE_URL}/auth/me", headers=headers)
    print(f"Status code: {profile_response.status_code}")
    pprint(profile_response.json())
    
    # Logout
    print("\n3. Logging out...")
    logout_response = requests.post(f"{BASE_URL}/auth/logout", headers=headers)
    print(f"Status code: {logout_response.status_code}")
    pprint(logout_response.json())
    
    # Try to use the token after logout
    print("\n4. Trying to use the token after logout...")
    profile_response = requests.get(f"{BASE_URL}/auth/me", headers=headers)
    print(f"Status code: {profile_response.status_code}")
    pprint(profile_response.json())
    
    # Try to refresh the token
    print("\n5. Trying to refresh the token...")
    refresh_headers = {
        "Authorisation": f"Bearer {refresh_token}"
    }
    refresh_response = requests.post(f"{BASE_URL}/auth/refresh", headers=refresh_headers)
    print(f"Status code: {refresh_response.status_code}")
    
    return True

def test_admin_endpoints(admin_email, admin_password):
    """Test the admin endpoints."""
    # Login as admin
    print("\n6. Logging in as admin...")
    login_data = {
        "email": admin_email,
        "password": admin_password
    }
    
    login_response = requests.post(f"{BASE_URL}/auth/login", json=login_data)
    print(f"Status code: {login_response.status_code}")
    
    if login_response.status_code != 200:
        print("Admin login failed.")
        return
    
    admin_token = login_response.json().get('access_token')
    admin_headers = {
        "Authorisation": f"Bearer {admin_token}"
    }
    
    # Get all users (admin only)
    print("\n7. Getting all users (admin only)...")
    users_response = requests.get(f"{BASE_URL}/admin/users", headers=admin_headers)
    print(f"Status code: {users_response.status_code}")
    
    if users_response.status_code == 200:
        users_data = users_response.json()
        print(f"Total users: {users_data.get('total')}")
    
    # Get admin statistics
    print("\n8. Getting admin statistics...")
    stats_response = requests.get(f"{BASE_URL}/admin/stats", headers=admin_headers)
    print(f"Status code: {stats_response.status_code}")
    
    if stats_response.status_code == 200:
        pprint(stats_response.json())
    
    return True

def run_tests():
    """Run all tests."""
    print("=== Testing Authentication Features ===")
    auth_tests_passed = test_register_login_logout()
    
    if auth_tests_passed:
        print("\n=== Authentication Tests Passed ===")
    else:
        print("\n=== Authentication Tests Failed ===")
    
    # You'll need to replace these with your actual admin credentials
    admin_email = input("\nEnter admin email: ")
    admin_password = input("Enter admin password: ")
    
    print("\n=== Testing Admin Features ===")
    admin_tests_passed = test_admin_endpoints(admin_email, admin_password)
    
    if admin_tests_passed:
        print("\n=== Admin Tests Passed ===")
    else:
        print("\n=== Admin Tests Failed ===")

if __name__ == "__main__":
    run_tests()

### File: C:\Users\rdjon\task-management-api\verify_models.py
from app import create_app, db
from app.models.user import User
from app.models.task import Task
from datetime import datetime, timedelta

def verify_models():
    """Verify that models are correctly implemented."""
    # Create a test-specific app with SQLite in-memory database
    app = create_app('app.config.TestingConfig')  # This uses SQLite in-memory
    
    with app.app_context():
        # Drop and recreate tables to start fresh
        db.drop_all()
        db.create_all()
        
        print("Testing User model...")
        
        # Create a test user
        user = User(
            username="testuser",
            email="test@example.com",
            password="password123"
        )
        db.session.add(user)
        db.session.commit()
        
        # Check if user was created successfully
        fetched_user = User.query.filter_by(username="testuser").first()
        assert fetched_user is not None, "User was not created or cannot be retrieved"
        assert fetched_user.email == "test@example.com", "User email does not match"
        assert fetched_user.check_password("password123"), "Password checking failed"
        
        print("User model verification passed!")
        
        print("Testing Task model...")
        
        # Create test tasks for the user
        tasks = [
            Task(
                title="Task 1",
                description="Description for Task 1",
                status="pending",
                priority="high",
                user_id=user.id,
                due_date=datetime.utcnow() + timedelta(days=1)
            ),
            Task(
                title="Task 2",
                description="Description for Task 2",
                status="in_progress",
                priority="medium",
                user_id=user.id
            )
        ]
        
        db.session.add_all(tasks)
        db.session.commit()
        
        # Check if tasks were created successfully
        user_tasks = Task.query.filter_by(user_id=user.id).all()
        assert len(user_tasks) == 2, f"Expected 2 tasks, but got {len(user_tasks)}"
        
        # Check task relationship
        assert len(user.tasks) == 2, f"User tasks relationship returned {len(user.tasks)} tasks instead of 2"
        
        # Check task conversion to dict
        task_dict = tasks[0].to_dict()
        assert task_dict['title'] == "Task 1", "Task to_dict() method failed"
        assert task_dict['status'] == "pending", "Task to_dict() method failed"
        
        print("Task model verification passed!")
        
        # Clean up
        db.session.delete(user)  # This should cascade delete the tasks
        db.session.commit()
        
        # Verify cascade delete
        remaining_tasks = Task.query.filter_by(user_id=user.id).all()
        assert len(remaining_tasks) == 0, "Cascade delete failed for tasks"
        
        print("All models verified successfully!")

if __name__ == "__main__":
    verify_models()

### File: C:\Users\rdjon\task-management-api\app\cli.py
import click
from flask.cli import with_appcontext
from app import db
from app.utils.db_init import init_db, drop_db, create_sample_data
from app.models.user import User
from app.utils.cleanup import cleanup_expired_tokens

def register_commands(app):
    """Register custom Flask CLI commands."""
    app.cli.add_command(init_db_command)
    app.cli.add_command(drop_db_command)
    app.cli.add_command(create_sample_data_command)
    app.cli.add_command(create_admin_command)
    app.cli.add_command(cleanup_tokens_command)

@click.command('init-db')
@with_appcontext
def init_db_command():
    """Initialise the database."""
    init_db()

@click.command('drop-db')
@with_appcontext
def drop_db_command():
    """Drop all database tables."""
    if click.confirm('Are you sure you want to drop all tables?'):
        drop_db()
    else:
        click.echo('Operation cancelled.')

@click.command('create-sample-data')
@with_appcontext
def create_sample_data_command():
    """Create sample data for development."""
    if click.confirm('Are you sure you want to create sample data?'):
        create_sample_data()
    else:
        click.echo('Operation cancelled.')

@click.command('create-admin')
@click.option('--username', prompt=True, help='Admin username')
@click.option('--email', prompt=True, help='Admin email')
@click.option('--password', prompt=True, hide_input=True, confirmation_prompt=True, help='Admin password')
@with_appcontext
def create_admin_command(username, email, password):
    """Create an admin user."""
    # Check if user already exists
    if User.query.filter_by(email=email).first():
        click.echo(f"User with email {email} already exists.")
        return
    
    if User.query.filter_by(username=username).first():
        click.echo(f"User with username {username} already exists.")
        return
    
    # Create admin user
    user = User(
        username=username,
        email=email,
        password=password,
        role='admin'
    )
    
    # Add user to database
    db.session.add(user)
    db.session.commit()
    
    click.echo(f"Admin user {username} created successfully.")

@click.command('cleanup-tokens')
@with_appcontext
def cleanup_tokens_command():
    """Clean up expired tokens from the blacklist."""
    result = cleanup_expired_tokens()
    
    if result >= 0:
        click.echo(f"Removed {result} expired tokens from the blacklist.")
    else:
        click.echo("Error cleaning up expired tokens.")

### File: C:\Users\rdjon\task-management-api\app\config.py
import os
from datetime import timedelta

class Config:
    """Base configuration."""
    SECRET_KEY = os.environ.get('SECRET_KEY', 'task-management-api-secret-key-2025')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY', 'task-management-api-jwt-secret-key-2025')
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(hours=1)
    JWT_REFRESH_TOKEN_EXPIRES = timedelta(days=30)
    JWT_TOKEN_LOCATION = ['headers']
    JWT_HEADER_NAME = 'Authorization'
    JWT_HEADER_TYPE = 'Bearer'
    CORS_HEADERS = 'Content-Type'
    # Enable JWT blacklist
    JWT_BLACKLIST_ENABLED = True
    JWT_BLACKLIST_TOKEN_CHECKS = ['access', 'refresh']
    # Rate limiting settings
    RATELIMIT_DEFAULT = "60 per minute"
    RATELIMIT_STORAGE_URL = "memory://"
    RATELIMIT_STRATEGY = "fixed-window"
    RATELIMIT_HEADERS_ENABLED = True
    
    # Email configuration
    MAIL_SERVER = os.environ.get('MAIL_SERVER', 'smtp.gmail.com')
    MAIL_PORT = int(os.environ.get('MAIL_PORT', 587))
    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', 'True').lower() == 'true'
    MAIL_USE_SSL = os.environ.get('MAIL_USE_SSL', 'False').lower() == 'true'
    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    MAIL_DEFAULT_SENDER = os.environ.get('MAIL_DEFAULT_SENDER', 'noreply@taskmanager.com')
    
    # Frontend URL for password reset links
    FRONTEND_URL = os.environ.get('FRONTEND_URL', 'http://localhost:3000')

class DevelopmentConfig(Config):
    """Development configuration."""
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL', 'postgresql://task_api_user:password@localhost/task_management')
    DEBUG = True
    
    # Email configuration for development
    MAIL_DEBUG = True
    MAIL_SUPPRESS_SEND = False  # Set to True to prevent sending emails in development

class TestingConfig(Config):
    """Testing configuration."""
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'
    DEBUG = True
    # Disable rate limiting in tests
    RATELIMIT_ENABLED = False
    # Suppress email sending in tests
    MAIL_SUPPRESS_SEND = True

class ProductionConfig(Config):
    """Production configuration."""
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')
    DEBUG = False
    JWT_COOKIE_SECURE = True
    SESSION_COOKIE_SECURE = True
    SESSION_COOKIE_HTTPONLY = True
    REMEMBER_COOKIE_SECURE = True
    REMEMBER_COOKIE_HTTPONLY = True
    # More restrictive rate limits for production
    RATELIMIT_DEFAULT = "20 per minute"
    
    # Email configuration for production
    MAIL_DEBUG = False
    MAIL_SUPPRESS_SEND = False

### File: C:\Users\rdjon\task-management-api\app\__init__.py
from flask import Flask, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_jwt_extended import JWTManager
from flask_cors import CORS
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from dotenv import load_dotenv

# --------------------------------------------------------------------- #
# Initialisation
# --------------------------------------------------------------------- #
load_dotenv()

db       = SQLAlchemy()
migrate  = Migrate()
jwt      = JWTManager()
cors     = CORS()
limiter  = Limiter(key_func=get_remote_address,
                   default_limits=["60 per minute"])

# Mail needs the app later
from app.utils.email import mail   # isort: skip

def create_app(config_object="app.config.DevelopmentConfig"):
    """Flask application-factory."""
    app = Flask(__name__)
    app.config.from_object(config_object)

    # Extensions
    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    cors.init_app(app)
    limiter.init_app(app)
    mail.init_app(app)

    # Import models so Alembic sees them
    from app.models import (  # noqa: F401
        user, task, tag, comment,
        token_blacklist, password_reset, activity_log
    )

    # ---------------------------------------- #
    # Register CLI commands
    # ---------------------------------------- #
    from app.cli import register_commands
    register_commands(app)

    # ---------------------------------------- #
    # Blueprints
    # ---------------------------------------- #
    from app.resources.auth     import auth_bp
    from app.resources.task     import task_bp
    from app.resources.tag      import tag_bp
    from app.resources.comment  import comment_bp
    from app.resources.export   import export_bp
    from app.resources.admin    import admin_bp
    from app.resources.activity import activity_bp   # <-- NEW
    from app.utils.api_docs     import api_docs_bp
    from app.resources.debug    import debug_bp

    app.register_blueprint(auth_bp,     url_prefix="/api/v1/auth")
    app.register_blueprint(task_bp,     url_prefix="/api/v1/tasks")
    app.register_blueprint(tag_bp,      url_prefix="/api/v1/tags")
    app.register_blueprint(comment_bp,  url_prefix="/api/v1")
    app.register_blueprint(export_bp,   url_prefix="/api/v1")
    app.register_blueprint(admin_bp,    url_prefix="/api/v1/admin")
    app.register_blueprint(activity_bp, url_prefix="/api/v1")  # <-- NEW
    app.register_blueprint(api_docs_bp, url_prefix="/api/v1/docs")
    app.register_blueprint(debug_bp,    url_prefix="/api/v1/debug")

    # ---------------------------------------- #
    # JWT blacklist callback
    # ---------------------------------------- #
    from app.models.token_blacklist import TokenBlacklist

    @jwt.token_in_blocklist_loader
    def _is_token_revoked(jwt_header, jwt_payload):
        return TokenBlacklist.is_token_revoked(jwt_payload)

    # Error handlers & 429 handler already present elsewhere
    from app.utils.errors import register_error_handlers
    register_error_handlers(app)

    # Shell context
    @app.shell_context_processor
    def _ctx():
        return dict(app=app, db=db)  # pragma: no cover

    # Root ping
    @app.route("/")
    def index():
        return jsonify({
            "message": "Welcome to the Task Management API",
            "version": "1.0.0"
        }), 200

    return app

### File: C:\Users\rdjon\task-management-api\app\models\activity_log.py
from app import db
from datetime import datetime
from enum import Enum

class ActivityType(Enum):
    """Types of activities that can be logged."""
    # Authentication
    USER_LOGIN = "user_login"
    USER_LOGOUT = "user_logout"
    USER_REGISTER = "user_register"
    PASSWORD_RESET_REQUEST = "password_reset_request"
    PASSWORD_RESET_COMPLETE = "password_reset_complete"
    
    # Task operations
    TASK_CREATE = "task_create"
    TASK_UPDATE = "task_update"
    TASK_DELETE = "task_delete"
    TASK_BULK_UPDATE = "task_bulk_update"
    TASK_BULK_DELETE = "task_bulk_delete"
    
    # Tag operations
    TAG_CREATE = "tag_create"
    TAG_UPDATE = "tag_update"
    TAG_DELETE = "tag_delete"
    TAG_ADDED_TO_TASK = "tag_added_to_task"
    TAG_REMOVED_FROM_TASK = "tag_removed_from_task"
    
    # Comment operations
    COMMENT_CREATE = "comment_create"
    COMMENT_UPDATE = "comment_update"
    COMMENT_DELETE = "comment_delete"
    
    # User operations
    USER_UPDATE = "user_update"
    USER_DELETE = "user_delete"

class ActivityLog(db.Model):
    """Model for logging user activities."""
    __tablename__ = 'activity_logs'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    activity_type = db.Column(db.String(50), nullable=False, index=True)
    entity_type = db.Column(db.String(50))  # e.g., 'task', 'tag', 'comment'
    entity_id = db.Column(db.Integer)  # ID of the affected entity
    description = db.Column(db.Text)
    activity_data = db.Column(db.JSON)  # Additional data about the activity (renamed from metadata)
    ip_address = db.Column(db.String(45))  # Support IPv6
    user_agent = db.Column(db.String(256))
    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)
    
    def __init__(self, user_id, activity_type, entity_type=None, entity_id=None, 
                 description=None, activity_data=None, ip_address=None, user_agent=None):
        self.user_id = user_id
        self.activity_type = activity_type.value if isinstance(activity_type, ActivityType) else activity_type
        self.entity_type = entity_type
        self.entity_id = entity_id
        self.description = description
        self.activity_data = activity_data
        self.ip_address = ip_address
        self.user_agent = user_agent
    
    def to_dict(self):
        """Convert activity log to dictionary."""
        return {
            'id': self.id,
            'user_id': self.user_id,
            'activity_type': self.activity_type,
            'entity_type': self.entity_type,
            'entity_id': self.entity_id,
            'description': self.description,
            'activity_data': self.activity_data,
            'ip_address': self.ip_address,
            'user_agent': self.user_agent,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }
    
    @classmethod
    def log(cls, user_id, activity_type, request=None, **kwargs):
        """Convenience method to log an activity."""
        log_entry = cls(
            user_id=user_id,
            activity_type=activity_type,
            entity_type=kwargs.get('entity_type'),
            entity_id=kwargs.get('entity_id'),
            description=kwargs.get('description'),
            activity_data=kwargs.get('activity_data'),  # Updated from metadata
            ip_address=request.remote_addr if request else None,
            user_agent=request.headers.get('User-Agent', '')[:256] if request else None
        )
        
        db.session.add(log_entry)
        # Note: Caller is responsible for committing the transaction
        return log_entry
    
    @classmethod
    def get_user_activities(cls, user_id, limit=50, offset=0, activity_types=None):
        """Get activities for a specific user."""
        query = cls.query.filter_by(user_id=user_id)
        
        if activity_types:
            query = query.filter(cls.activity_type.in_(activity_types))
        
        return query.order_by(cls.created_at.desc()).limit(limit).offset(offset).all()
    
    @classmethod
    def get_entity_history(cls, entity_type, entity_id, limit=50):
        """Get activity history for a specific entity."""
        return cls.query.filter_by(
            entity_type=entity_type,
            entity_id=entity_id
        ).order_by(cls.created_at.desc()).limit(limit).all()
    
    def __repr__(self):
        return f'<ActivityLog {self.activity_type} by user {self.user_id}>'

### File: C:\Users\rdjon\task-management-api\app\models\comment.py
from app import db
from datetime import datetime

class Comment(db.Model):
    """Comment model for storing task comments."""
    __tablename__ = 'comments'
    
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Foreign Keys
    task_id = db.Column(db.Integer, db.ForeignKey('tasks.id', ondelete='CASCADE'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    
    def __init__(self, content, task_id, user_id):
        self.content = content
        self.task_id = task_id
        self.user_id = user_id
    
    def to_dict(self):
        """Convert comment object to dictionary."""
        return {
            'id': self.id,
            'content': self.content,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'task_id': self.task_id,
            'user_id': self.user_id
        }
    
    def __repr__(self):
        return f'<Comment {self.id}>'

### File: C:\Users\rdjon\task-management-api\app\models\password_reset.py
from app import db
from datetime import datetime, timedelta
import secrets

class PasswordResetToken(db.Model):
    """Model for storing password reset tokens."""
    __tablename__ = 'password_reset_tokens'
    
    id = db.Column(db.Integer, primary_key=True)
    token = db.Column(db.String(100), unique=True, nullable=False, index=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    expires_at = db.Column(db.DateTime, nullable=False)
    used = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    def __init__(self, user_id, expires_in_hours=24):
        self.token = secrets.token_urlsafe(32)
        self.user_id = user_id
        self.expires_at = datetime.utcnow() + timedelta(hours=expires_in_hours)
    
    @property
    def is_expired(self):
        """Check if token has expired."""
        return datetime.utcnow() > self.expires_at
    
    @property
    def is_valid(self):
        """Check if token is valid (not expired and not used)."""
        return not self.is_expired and not self.used
    
    def mark_as_used(self):
        """Mark token as used."""
        self.used = True
    
    @classmethod
    def get_valid_token(cls, token):
        """Get a valid token by token string."""
        reset_token = cls.query.filter_by(token=token, used=False).first()
        if reset_token and reset_token.is_valid:
            return reset_token
        return None
    
    def __repr__(self):
        return f'<PasswordResetToken {self.token[:8]}...>'

### File: C:\Users\rdjon\task-management-api\app\models\tag.py
from app import db

# Many-to-many relationship table between tasks and tags
task_tags = db.Table('task_tags',
    db.Column('task_id', db.Integer, db.ForeignKey('tasks.id'), primary_key=True),
    db.Column('tag_id', db.Integer, db.ForeignKey('tags.id'), primary_key=True)
)

class Tag(db.Model):
    """Tag model for categorizing tasks."""
    __tablename__ = 'tags'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True, nullable=False)
    color = db.Column(db.String(7), default="#3498db")  # Default to a blue color
    user_id = db.Column(db.Integer, db.ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    
    # Relationships
    tasks = db.relationship(
    'Task',
    secondary=task_tags,
    lazy='selectin',
    backref=db.backref('tags', lazy='selectin')
    )
    
    def __init__(self, name, user_id, color="#3498db"):
        self.name = name
        self.user_id = user_id
        self.color = color
    
    def to_dict(self):
        """Convert tag object to dictionary."""
        return {
            'id': self.id,
            'name': self.name,
            'color': self.color,
            'user_id': self.user_id
        }
    
    def __repr__(self):
        return f'<Tag {self.name}>'

### File: C:\Users\rdjon\task-management-api\app\models\task.py
from app import db
from datetime import datetime

class Task(db.Model):
    """Task model for storing task related details."""
    __tablename__ = 'tasks'
    
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    status = db.Column(db.String(20), default='pending', index=True)  # pending, in_progress, completed
    priority = db.Column(db.String(20), default='medium', index=True)  # low, medium, high
    due_date = db.Column(db.DateTime, index=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Foreign Keys
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, index=True)
    
    # Relationships
    comments = db.relationship('Comment', backref='task', lazy=True, cascade='all, delete-orphan')
    
    # The tags relationship is defined in the Tag model via the task_tags table
    
    def __init__(self, title, user_id, description=None, status='pending', 
                 priority='medium', due_date=None):
        self.title = title
        self.user_id = user_id
        self.description = description
        self.status = status
        self.priority = priority
        self.due_date = due_date
    
    def to_dict(self):
        """Convert task object to dictionary."""
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'status': self.status,
            'priority': self.priority,
            'due_date': self.due_date.isoformat() if self.due_date else None,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'user_id': self.user_id
        }
    
    def __repr__(self):
        return f'<Task {self.title}>'

### File: C:\Users\rdjon\task-management-api\app\models\token_blacklist.py
from app import db
from datetime import datetime

class TokenBlacklist(db.Model):
    """Model for storing blacklisted tokens."""
    __tablename__ = 'token_blacklist'
    
    id = db.Column(db.Integer, primary_key=True)
    jti = db.Column(db.String(36), nullable=False, unique=True)
    token_type = db.Column(db.String(10), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    revoked_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    expires_at = db.Column(db.DateTime, nullable=False)
    
    def __repr__(self):
        return f'<TokenBlacklist {self.jti}>'
    
    @classmethod
    def is_token_revoked(cls, jwt_payload):
        """Check if the given token is blacklisted."""
        jti = jwt_payload['jti']
        return cls.query.filter_by(jti=jti).first() is not None

### File: C:\Users\rdjon\task-management-api\app\models\user.py
from app import db
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash

class User(db.Model):
    """User model for storing user related details."""
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False, index=True)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(256), nullable=False)
    # Add role field (admin, user)
    role = db.Column(db.String(20), default='user', nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    tasks = db.relationship('Task', backref='user', lazy=True, cascade='all, delete-orphan')
    tags = db.relationship('Tag', backref='user', lazy=True, cascade='all, delete-orphan')
    comments = db.relationship('Comment', backref='user', lazy=True, cascade='all, delete-orphan')
    blacklisted_tokens = db.relationship('TokenBlacklist', backref='user', lazy=True, cascade='all, delete-orphan')
    
    def __init__(self, username, email, password, role='user'):
        self.username = username
        self.email = email
        self.set_password(password)
        self.role = role
    
    def set_password(self, password):
        """Set password hash."""
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        """Check password hash."""
        return check_password_hash(self.password_hash, password)
    
    def is_admin(self):
        """Check if user is an admin."""
        return self.role == 'admin'
    
    def to_dict(self):
        """Convert user object to dictionary."""
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'role': self.role,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        }
    
    def __repr__(self):
        return f'<User {self.username}>'

### File: C:\Users\rdjon\task-management-api\app\models\__init__.py
from app.models.user import User
from app.models.task import Task
from app.models.token_blacklist import TokenBlacklist
from app.models.tag import Tag
from app.models.comment import Comment
from app.models.password_reset import PasswordResetToken
from app.models.activity_log import ActivityLog

### File: C:\Users\rdjon\task-management-api\app\resources\activity.py
"""
User activity feed endpoints.

Added 2025-06-04
"""
from flask import Blueprint, jsonify, request
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.models.activity_log import ActivityLog

activity_bp = Blueprint("activity", __name__)

@activity_bp.route("/activities", methods=["GET"])
@jwt_required()
def get_my_activities():
    """
    Return the authenticated user’s recent activity log entries.

    Query-string parameters (all optional):
        limit   – max rows to return (default 50, max 100)
        offset  – starting row (default 0)
    """
    user_id = get_jwt_identity()
    if isinstance(user_id, str):
        user_id = int(user_id)

    try:
        limit = min(int(request.args.get("limit", 50)), 100)
        offset = int(request.args.get("offset", 0))
    except ValueError:
        return jsonify({"error": "limit and offset must be integers"}), 400

    logs = ActivityLog.get_user_activities(
        user_id=user_id,
        limit=limit,
        offset=offset
    )

    return jsonify([entry.to_dict() for entry in logs]), 200

### File: C:\Users\rdjon\task-management-api\app\resources\admin.py
from flask import Blueprint, request, jsonify
from flask_jwt_extended import get_jwt_identity
from app.utils.auth import admin_required
from app.models.user import User
from app.schemas import user_schema, users_schema
from app import db
from marshmallow import ValidationError

admin_bp = Blueprint('admin', __name__)

@admin_bp.route('/users', methods=['GET'])
@admin_required
def get_users():
    """Get all users (admin only)."""
    # Get query parameters for pagination
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)

    # Paginate users
    pagination = User.query.paginate(page=page, per_page=per_page)

    return jsonify({
        "users": users_schema.dump(pagination.items),
        "total": pagination.total,
        "pages": pagination.pages,
        "page": page,
        "per_page": per_page
    }), 200

@admin_bp.route('/users/<int:user_id>', methods=['GET'])
@admin_required
def get_user(user_id):
    """Get a specific user (admin only)."""
    user = User.query.get(user_id)

    if not user:
        return jsonify({"error": "User not found"}), 404

    return jsonify(user_schema.dump(user)), 200

@admin_bp.route('/users/<int:user_id>', methods=['PUT'])
@admin_required
def update_user(user_id):
    """Update a specific user (admin only)."""
    # Fetch the target user
    user = User.query.get(user_id)
    if not user:
        return jsonify({"error": "User not found"}), 404

    # Disallow an admin from updating themselves via this endpoint
    current_user_id = get_jwt_identity()
    if isinstance(current_user_id, str):
        try:
            current_user_id = int(current_user_id)
        except ValueError:
            pass

    if current_user_id == user_id:
        return jsonify({"error": "Admin privileges required"}), 403

    # Get the updates from the request
    data = request.get_json() or {}

    # Update username if provided and not taken
    if 'username' in data and data['username'] != user.username:
        if User.query.filter_by(username=data['username']).first():
            return jsonify({"error": "Username already taken"}), 409
        user.username = data['username']

    # Update email if provided and not taken
    if 'email' in data and data['email'] != user.email:
        if User.query.filter_by(email=data['email']).first():
            return jsonify({"error": "Email already taken"}), 409
        user.email = data['email']

    # Update role if provided
    if 'role' in data and data['role'] in ['user', 'admin']:
        user.role = data['role']

    # Update password if provided
    if 'password' in data:
        user.set_password(data['password'])

    # Commit all changes
    db.session.commit()

    return jsonify({
        "message": "User updated successfully",
        "user": user_schema.dump(user)
    }), 200

@admin_bp.route('/users/<int:user_id>', methods=['DELETE'])
@admin_required
def delete_user(user_id):
    """Delete a specific user (admin only)."""
    user = User.query.get(user_id)

    if not user:
        return jsonify({"error": "User not found"}), 404

    db.session.delete(user)
    db.session.commit()

    return jsonify({
        "message": "User deleted successfully"
    }), 200

@admin_bp.route('/stats', methods=['GET'])
@admin_required
def get_admin_statistics():
    """Get admin statistics (admin only)."""
    # Get total users
    total_users = User.query.count()

    # Get users by role
    admin_users = User.query.filter_by(role='admin').count()
    regular_users = User.query.filter_by(role='user').count()

    # Get total tasks
    from app.models.task import Task
    total_tasks = Task.query.count()

    # Get tasks by status
    from sqlalchemy import func
    task_by_status = db.session.query(
        Task.status, func.count(Task.id)
    ).group_by(Task.status).all()
    status_stats = {status: count for status, count in task_by_status}

    return jsonify({
        "user_stats": {
            "total": total_users,
            "admins": admin_users,
            "regular_users": regular_users
        },
        "task_stats": {
            "total": total_tasks,
            "by_status": status_stats
        }
    }), 200

### File: C:\Users\rdjon\task-management-api\app\resources\auth.py
from flask import Blueprint, request, jsonify
from flask_jwt_extended import (
    create_access_token, create_refresh_token, jwt_required, 
    get_jwt_identity, get_jwt, verify_jwt_in_request
)
from marshmallow import ValidationError
from datetime import datetime, timezone
from app import db, limiter
from app.models.user import User
from app.models.token_blacklist import TokenBlacklist
from app.models.password_reset import PasswordResetToken
from app.schemas import user_registration_schema, user_login_schema, user_schema
from app.utils.email import send_password_reset_email, send_password_reset_confirmation_email

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/register', methods=['POST'])
@limiter.limit("10 per hour")
def register():
    """Register a new user."""
    try:
        # Validate and deserialise input
        data = user_registration_schema.load(request.json)
    except ValidationError as err:
        return jsonify({"error": "Validation error", "messages": err.messages}), 400
    
    # Check if user already exists
    if User.query.filter_by(email=data['email']).first():
        return jsonify({"error": "User with this email already exists"}), 409
    
    if User.query.filter_by(username=data['username']).first():
        return jsonify({"error": "User with this username already exists"}), 409
    
    # Create new user
    user = User(
        username=data['username'],
        email=data['email'],
        password=data['password'],
        role=data.get('role', 'user')  # Default to 'user' role
    )
    
    # Add user to database
    db.session.add(user)
    db.session.commit()
    
    # Create tokens - IMPORTANT: Convert user.id to string
    access_token = create_access_token(identity=str(user.id))
    refresh_token = create_refresh_token(identity=str(user.id))
    
    return jsonify({
        "message": "User registered successfully",
        "user": user_schema.dump(user),
        "access_token": access_token,
        "refresh_token": refresh_token
    }), 201

@auth_bp.route('/login', methods=['POST'])
@limiter.limit("20 per hour")
def login():
    """Login a user."""
    try:
        # Validate and deserialise input
        data = user_login_schema.load(request.json)
    except ValidationError as err:
        return jsonify({"error": "Validation error", "messages": err.messages}), 400
    
    # Check if user exists
    user = User.query.filter_by(email=data['email']).first()
    if not user or not user.check_password(data['password']):
        return jsonify({"error": "Invalid credentials"}), 401
    
    # Create tokens - IMPORTANT: Convert user.id to string
    access_token = create_access_token(identity=str(user.id))
    refresh_token = create_refresh_token(identity=str(user.id))
    
    return jsonify({
        "message": "Login successful",
        "user": user_schema.dump(user),
        "access_token": access_token,
        "refresh_token": refresh_token
    }), 200

@auth_bp.route('/refresh', methods=['POST'])
@limiter.limit("20 per minute")
@jwt_required(refresh=True)
def refresh():
    """Refresh access token."""
    current_user = get_jwt_identity()
    access_token = create_access_token(identity=current_user)
    
    return jsonify({
        "access_token": access_token
    }), 200

@auth_bp.route('/logout', methods=['POST'])
@jwt_required()
def logout():
    """Logout a user by revoking their token."""
    jwt_payload = get_jwt()
    jti = jwt_payload['jti']
    user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(user_id, str):
        user_id = int(user_id)
    
    # Add token to blacklist
    token_type = jwt_payload['type']
    expires_at = datetime.fromtimestamp(jwt_payload['exp'], timezone.utc)
    
    token_blacklist = TokenBlacklist(
        jti=jti,
        token_type=token_type,
        user_id=user_id,
        expires_at=expires_at
    )
    
    db.session.add(token_blacklist)
    db.session.commit()
    
    return jsonify({
        "message": "Successfully logged out"
    }), 200

@auth_bp.route('/logout/all', methods=['POST'])
@limiter.limit("5 per hour")
@jwt_required()
def logout_all():
    """Logout from all devices by blacklisting all user tokens."""
    user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(user_id, str):
        user_id = int(user_id)
    
    # Add current token to blacklist
    jwt_payload = get_jwt()
    jti = jwt_payload['jti']
    token_type = jwt_payload['type']
    expires_at = datetime.fromtimestamp(jwt_payload['exp'], timezone.utc)
    
    token_blacklist = TokenBlacklist(
        jti=jti,
        token_type=token_type,
        user_id=user_id,
        expires_at=expires_at
    )
    
    db.session.add(token_blacklist)
    
    # Note: In a real production app, you might want to implement a mechanism to 
    # blacklist all existing tokens for a user. This would require maintaining 
    # a list of all active tokens or using a timestamp approach.
    
    db.session.commit()
    
    return jsonify({
        "message": "Successfully logged out from all devices"
    }), 200

@auth_bp.route('/me', methods=['GET'])
@jwt_required()
def me():
    """Get current user details."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
        
    user = User.query.get(current_user_id)
    
    if not user:
        return jsonify({"error": "User not found"}), 404
    
    return jsonify(user_schema.dump(user)), 200

@auth_bp.route('/me', methods=['PUT'])
@limiter.limit("20 per hour")
@jwt_required()
def update_me():
    """Update current user details."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
        
    user = User.query.get(current_user_id)
    
    if not user:
        return jsonify({"error": "User not found"}), 404
    
    # Get the updates from the request
    data = request.json
    
    # Update username if provided and not taken
    if 'username' in data and data['username'] != user.username:
        if User.query.filter_by(username=data['username']).first():
            return jsonify({"error": "Username already taken"}), 409
        user.username = data['username']
    
    # Update email if provided and not taken
    if 'email' in data and data['email'] != user.email:
        if User.query.filter_by(email=data['email']).first():
            return jsonify({"error": "Email already taken"}), 409
        user.email = data['email']
    
    # Update password if provided
    if 'password' in data:
        user.set_password(data['password'])
    
    # Save changes
    db.session.commit()
    
    return jsonify({
        "message": "User updated successfully",
        "user": user_schema.dump(user)
    }), 200

@auth_bp.route('/forgot-password', methods=['POST'])
@limiter.limit("5 per hour")
def forgot_password():
    """Request a password reset."""
    data = request.get_json()
    
    if not data or 'email' not in data:
        return jsonify({"error": "Email is required"}), 400
    
    email = data['email']
    user = User.query.filter_by(email=email).first()
    
    # Always return success to prevent email enumeration
    if user:
        # Create password reset token
        reset_token = PasswordResetToken(user_id=user.id)
        db.session.add(reset_token)
        db.session.commit()
        
        # Send password reset email
        try:
            send_password_reset_email(user, reset_token.token)
        except Exception as e:
            # Log the error but don't expose it to the user
            print(f"Error sending password reset email: {str(e)}")
    
    return jsonify({
        "message": "If an account exists with this email, you will receive password reset instructions."
    }), 200

@auth_bp.route('/reset-password', methods=['POST'])
@limiter.limit("10 per hour")
def reset_password():
    """Reset password using token."""
    data = request.get_json()
    
    if not data or 'token' not in data or 'password' not in data:
        return jsonify({"error": "Token and new password are required"}), 400
    
    token = data['token']
    new_password = data['password']
    
    # Validate password length
    if len(new_password) < 8:
        return jsonify({"error": "Password must be at least 8 characters long"}), 400
    
    # Get valid token
    reset_token = PasswordResetToken.get_valid_token(token)
    
    if not reset_token:
        return jsonify({"error": "Invalid or expired token"}), 400
    
    # Get user
    user = User.query.get(reset_token.user_id)
    
    if not user:
        return jsonify({"error": "User not found"}), 404
    
    # Update password
    user.set_password(new_password)
    
    # Mark token as used
    reset_token.mark_as_used()
    
    # Save changes
    db.session.commit()
    
    # Send confirmation email
    try:
        send_password_reset_confirmation_email(user)
    except Exception as e:
        # Log the error but don't fail the request
        print(f"Error sending confirmation email: {str(e)}")
    
    return jsonify({
        "message": "Password reset successfully"
    }), 200

@auth_bp.route('/verify-reset-token', methods=['POST'])
def verify_reset_token():
    """Verify if a password reset token is valid."""
    data = request.get_json()
    
    if not data or 'token' not in data:
        return jsonify({"error": "Token is required"}), 400
    
    token = data['token']
    reset_token = PasswordResetToken.get_valid_token(token)
    
    if reset_token:
        return jsonify({
            "valid": True,
            "message": "Token is valid"
        }), 200
    else:
        return jsonify({
            "valid": False,
            "message": "Invalid or expired token"
        }), 200

### File: C:\Users\rdjon\task-management-api\app\resources\comment.py
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from marshmallow import ValidationError
from app import db
from app.models.comment import Comment
from app.models.task import Task
from app.schemas import comment_schema, comments_schema

comment_bp = Blueprint('comment', __name__)

@comment_bp.route('/tasks/<int:task_id>/comments', methods=['GET'])
@jwt_required()
def get_task_comments(task_id):
    """Get all comments for a specific task."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
    
    # Check if task exists and belongs to the user
    task = Task.query.filter_by(id=task_id, user_id=current_user_id).first()
    
    if not task:
        return jsonify({"error": "Task not found"}), 404
    
    # Get comments for the task
    comments = Comment.query.filter_by(task_id=task_id).order_by(Comment.created_at).all()
    
    return jsonify(comments_schema.dump(comments)), 200

@comment_bp.route('/tasks/<int:task_id>/comments', methods=['POST'])
@jwt_required()
def create_comment(task_id):
    """Create a new comment for a task."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
    
    # Check if task exists and belongs to the user
    task = Task.query.filter_by(id=task_id, user_id=current_user_id).first()
    
    if not task:
        return jsonify({"error": "Task not found"}), 404
    
    try:
        # Validate and deserialise input
        data = comment_schema.load(request.json)
    except ValidationError as err:
        return jsonify({"error": "Validation error", "messages": err.messages}), 400
    
    # Create new comment
    comment = Comment(
        content=data['content'],
        task_id=task_id,
        user_id=current_user_id
    )
    
    # Add comment to database
    db.session.add(comment)
    db.session.commit()
    
    return jsonify({
        "message": "Comment created successfully",
        "comment": comment_schema.dump(comment)
    }), 201

@comment_bp.route('/comments/<int:comment_id>', methods=['GET'])
@jwt_required()
def get_comment(comment_id):
    """Get a specific comment."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
    
    comment = Comment.query.filter_by(id=comment_id).first()
    
    if not comment:
        return jsonify({"error": "Comment not found"}), 404
    
    # Check if comment belongs to a task owned by the user
    task = Task.query.filter_by(id=comment.task_id, user_id=current_user_id).first()
    
    if not task:
        return jsonify({"error": "You do not have permission to access this comment"}), 403
    
    return jsonify(comment_schema.dump(comment)), 200

@comment_bp.route('/comments/<int:comment_id>', methods=['PUT'])
@jwt_required()
def update_comment(comment_id):
    """Update a specific comment."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
    
    comment = Comment.query.filter_by(id=comment_id).first()
    
    if not comment:
        return jsonify({"error": "Comment not found"}), 404
    
    # Check if comment belongs to the user
    if comment.user_id != current_user_id:
        return jsonify({"error": "You do not have permission to update this comment"}), 403
    
    try:
        # Validate and deserialise input
        data = comment_schema.load(request.json)
    except ValidationError as err:
        return jsonify({"error": "Validation error", "messages": err.messages}), 400
    
    # Update comment content
    comment.content = data['content']
    
    # Update comment in database
    db.session.commit()
    
    return jsonify({
        "message": "Comment updated successfully",
        "comment": comment_schema.dump(comment)
    }), 200

@comment_bp.route('/comments/<int:comment_id>', methods=['DELETE'])
@jwt_required()
def delete_comment(comment_id):
    """Delete a specific comment."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
    
    comment = Comment.query.filter_by(id=comment_id).first()
    
    if not comment:
        return jsonify({"error": "Comment not found"}), 404
    
    # Check if comment belongs to the user or if the user owns the task
    task = Task.query.filter_by(id=comment.task_id, user_id=current_user_id).first()
    
    if comment.user_id != current_user_id and not task:
        return jsonify({"error": "You do not have permission to delete this comment"}), 403
    
    # Delete comment from database
    db.session.delete(comment)
    db.session.commit()
    
    return jsonify({
        "message": "Comment deleted successfully"
    }), 200

### File: C:\Users\rdjon\task-management-api\app\resources\debug.py
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity, verify_jwt_in_request, get_jwt
import jwt
from flask import current_app

debug_bp = Blueprint('debug', __name__)

@debug_bp.route('/auth-test', methods=['GET'])
def auth_test():
    """Test authentication without JWT requirement."""
    auth_header = request.headers.get('Authorization', '')
    
    debug_info = {
        "has_auth_header": auth_header != '',
        "auth_header": auth_header,
        "all_headers": dict(request.headers),
        "flask_jwt_settings": {
            "secret_key": current_app.config.get('JWT_SECRET_KEY'),
            "algorithm": current_app.config.get('JWT_ALGORITHM', 'HS256'),
            "header_type": current_app.config.get('JWT_HEADER_TYPE'),
            "token_location": current_app.config.get('JWT_TOKEN_LOCATION')
        }
    }
    
    # Try to manually verify the token
    if auth_header.startswith('Bearer '):
        token = auth_header[7:]  # Remove 'Bearer ' prefix
        debug_info["token"] = token
        
        try:
            # Try to manually decode token
            decoded = jwt.decode(
                token, 
                current_app.config.get('JWT_SECRET_KEY'), 
                algorithms=[current_app.config.get('JWT_ALGORITHM', 'HS256')]
            )
            debug_info["manual_decode"] = {
                "success": True,
                "decoded": decoded
            }
        except Exception as e:
            debug_info["manual_decode"] = {
                "success": False,
                "error": str(e)
            }
        
        # Try Flask-JWT-Extended verification
        try:
            verify_jwt_in_request()
            user_id = get_jwt_identity()
            jwt_data = get_jwt()
            debug_info["jwt_extended_verify"] = {
                "success": True,
                "user_id": user_id,
                "jwt_data": jwt_data
            }
        except Exception as e:
            debug_info["jwt_extended_verify"] = {
                "success": False,
                "error": str(e)
            }
    
    return jsonify(debug_info), 200

@debug_bp.route('/protected', methods=['GET'])
@jwt_required()
def protected():
    """A protected endpoint that requires JWT."""
    current_user_id = get_jwt_identity()
    return jsonify({
        "message": "Access granted to protected endpoint!",
        "user_id": current_user_id
    }), 200

### File: C:\Users\rdjon\task-management-api\app\resources\export.py
from flask import Blueprint, request, jsonify, Response
from flask_jwt_extended import jwt_required, get_jwt_identity
import json
import csv
from io import StringIO
from app.models.task import Task
from app.models.tag import Tag
from app.schemas import tasks_schema

export_bp = Blueprint('export', __name__)

@export_bp.route('/tasks/export', methods=['GET'])
@jwt_required()
def export_tasks():
    """Export tasks in different formats (json, csv)."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
    
    # Get format parameter
    export_format = request.args.get('format', 'json').lower()
    
    # Get optional filters
    status = request.args.get('status')
    priority = request.args.get('priority')
    tag_id = request.args.get('tag_id')
    
    # Base query
    query = Task.query.filter_by(user_id=current_user_id)
    
    # Apply filters if provided
    if status:
        query = query.filter_by(status=status)
    if priority:
        query = query.filter_by(priority=priority)
    if tag_id:
        query = query.join(Task.tags).filter(Tag.id == tag_id)
    
    # Get all tasks
    tasks = query.all()
    
    if export_format == 'json':
        # Serialise tasks to JSON
        serialised_tasks = tasks_schema.dump(tasks)
        return jsonify(serialised_tasks)
    
    elif export_format == 'csv':
        # Prepare CSV data
        output = StringIO()
        writer = csv.writer(output)
        
        # Write header row
        writer.writerow(['ID', 'Title', 'Description', 'Status', 'Priority', 'Due Date', 'Created At', 'Updated At', 'Tags'])
        
        # Write data rows
        for task in tasks:
            # Get tags as comma-separated string
            tags_str = ', '.join([tag.name for tag in task.tags])
            
            writer.writerow([
                task.id,
                task.title,
                task.description or '',  # Handle None values
                task.status,
                task.priority,
                task.due_date.isoformat() if task.due_date else '',
                task.created_at.isoformat(),
                task.updated_at.isoformat(),
                tags_str
            ])
        
        # Prepare response
        response = Response(output.getvalue(), mimetype='text/csv')
        response.headers['Content-Disposition'] = 'attachment; filename=tasks.csv'
        
        return response
    
    else:
        return jsonify({
            "error": "Unsupported export format",
            "supported_formats": ["json", "csv"]
        }), 400

### File: C:\Users\rdjon\task-management-api\app\resources\tag.py
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from marshmallow import ValidationError
from app import db
from app.models.tag import Tag
from app.schemas import tag_schema, tags_schema

tag_bp = Blueprint('tag', __name__)

@tag_bp.route('', methods=['GET'])
@jwt_required()
def get_tags():
    """Get all tags for the current user."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
    
    tags = Tag.query.filter_by(user_id=current_user_id).all()
    
    return jsonify(tags_schema.dump(tags)), 200

@tag_bp.route('/<int:tag_id>', methods=['GET'])
@jwt_required()
def get_tag(tag_id):
    """Get a specific tag."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
    
    tag = Tag.query.filter_by(id=tag_id, user_id=current_user_id).first()
    
    if not tag:
        return jsonify({"error": "Tag not found"}), 404
    
    return jsonify(tag_schema.dump(tag)), 200

@tag_bp.route('', methods=['POST'])
@jwt_required()
def create_tag():
    """Create a new tag."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
    
    try:
        # Validate and deserialise input
        data = tag_schema.load(request.json)
    except ValidationError as err:
        return jsonify({"error": "Validation error", "messages": err.messages}), 400
    
    # Check if tag with the same name already exists for this user
    existing_tag = Tag.query.filter_by(name=data['name'], user_id=current_user_id).first()
    if existing_tag:
        return jsonify({"error": "Tag with this name already exists"}), 409
    
    # Create new tag
    tag = Tag(
        name=data['name'],
        user_id=current_user_id,
        color=data.get('color', "#3498db")
    )
    
    # Add tag to database
    db.session.add(tag)
    db.session.commit()
    
    return jsonify({
        "message": "Tag created successfully",
        "tag": tag_schema.dump(tag)
    }), 201

@tag_bp.route('/<int:tag_id>', methods=['PUT'])
@jwt_required()
def update_tag(tag_id):
    """Update a specific tag."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
    
    tag = Tag.query.filter_by(id=tag_id, user_id=current_user_id).first()
    
    if not tag:
        return jsonify({"error": "Tag not found"}), 404
    
    try:
        # Validate and deserialise input
        data = tag_schema.load(request.json, partial=True)
    except ValidationError as err:
        return jsonify({"error": "Validation error", "messages": err.messages}), 400
    
    # Check if new name conflicts with existing tag
    if 'name' in data and data['name'] != tag.name:
        existing_tag = Tag.query.filter_by(name=data['name'], user_id=current_user_id).first()
        if existing_tag:
            return jsonify({"error": "Tag with this name already exists"}), 409
        tag.name = data['name']
    
    # Update color if provided
    if 'color' in data:
        tag.color = data['color']
    
    # Update tag in database
    db.session.commit()
    
    return jsonify({
        "message": "Tag updated successfully",
        "tag": tag_schema.dump(tag)
    }), 200

@tag_bp.route('/<int:tag_id>', methods=['DELETE'])
@jwt_required()
def delete_tag(tag_id):
    """Delete a specific tag."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
    
    tag = Tag.query.filter_by(id=tag_id, user_id=current_user_id).first()
    
    if not tag:
        return jsonify({"error": "Tag not found"}), 404
    
    # Remove tag from database
    db.session.delete(tag)
    db.session.commit()
    
    return jsonify({
        "message": "Tag deleted successfully"
    }), 200

### File: C:\Users\rdjon\task-management-api\app\resources\task.py
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from marshmallow import ValidationError
from datetime import datetime
from sqlalchemy import desc, asc, or_
from sqlalchemy.orm import selectinload, joinedload

from app import db
from app.models.task import Task
from app.models.tag import Tag
from app.models.activity_log import ActivityType
from app.schemas import (
    task_schema, tasks_schema, task_query_schema,
    task_bulk_delete_schema, task_bulk_update_schema
)

# **NEW IMPORTS FOR LOGGING**
from app.utils.activity_logger import (
    log_activity,
    get_task_id_from_response
)

task_bp = Blueprint('task', __name__)

# ---------------------------------------------------------------------- #
# Query helpers – unchanged
# ---------------------------------------------------------------------- #
@task_bp.route('', methods=['GET'])
@jwt_required()
def get_tasks():
    """Get all tasks for the current user."""
    current_user_id = get_jwt_identity()
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)

    # Validate query parameters
    raw = {k: v for k, v in request.args.items() if v}
    try:
        q = task_query_schema.load(raw)
    except ValidationError as err:
        return jsonify({"error": "Invalid query parameters",
                        "messages": err.messages}), 400

    query = Task.query.options(selectinload(Task.tags)) \
                       .filter_by(user_id=current_user_id)

    if 'status' in q:    query = query.filter_by(status=q['status'])
    if 'priority' in q:  query = query.filter_by(priority=q['priority'])
    if 'search' in q:
        term = f"%{q['search']}%"
        query = query.filter(or_(Task.title.ilike(term),
                                 Task.description.ilike(term)))
    if 'tag' in q:
        query = query.join(Task.tags).filter(Tag.id == q['tag'])
    if 'due_before' in q: query = query.filter(Task.due_date <= q['due_before'])
    if 'due_after' in q:  query = query.filter(Task.due_date >= q['due_after'])

    sort_attr = getattr(Task, q.get('sort_by', 'created_at'))
    query = query.order_by(desc(sort_attr) if q.get('sort_order', 'desc') == 'desc'
                           else asc(sort_attr))

    page      = q.get('page', 1)
    per_page  = q.get('per_page', 10)
    total     = query.count()
    items     = query.limit(per_page).offset((page-1)*per_page).all()
    pages     = (total + per_page - 1) // per_page

    return jsonify({
        "tasks": tasks_schema.dump(items),
        "total": total,
        "pages": pages,
        "page": page,
        "per_page": per_page
    }), 200

@task_bp.route('/<int:task_id>', methods=['GET'])
@jwt_required()
def get_task(task_id):
    """Get a specific task."""
    current_user_id = get_jwt_identity()
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)

    task = (
        Task.query
            .options(joinedload(Task.tags), joinedload(Task.comments))
            .filter_by(id=task_id, user_id=current_user_id)
            .first()
    )
    if not task:
        return jsonify({"error": "Task not found"}), 404

    return jsonify(task_schema.dump(task)), 200

# ---------------------------------------------------------------------- #
# Create / update / delete – now with @log_activity
# ---------------------------------------------------------------------- #
@task_bp.route('', methods=['POST'])
@jwt_required()
@log_activity(               # <-- NEW
    activity_type=ActivityType.TASK_CREATE,
    entity_type="task",
    get_entity_id=get_task_id_from_response
)
def create_task():
    """Create a new task."""
    current_user_id = get_jwt_identity()
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)

    try:
        data = task_schema.load(request.json)
    except ValidationError as err:
        return jsonify({"error": "Validation error",
                        "messages": err.messages}), 400

    task = Task(
        title=data['title'],
        user_id=current_user_id,
        description=data.get('description'),
        status=data.get('status', 'pending'),
        priority=data.get('priority', 'medium'),
        due_date=data.get('due_date')
    )
    db.session.add(task)
    db.session.commit()

    # Handle tags if supplied
    if data.get('tag_ids'):
        tags = Tag.query.filter(
            Tag.id.in_(data['tag_ids']),
            Tag.user_id == current_user_id
        ).all()
        if len(tags) != len(data['tag_ids']):
            return jsonify({"error": "One or more tags not found"}), 404
        task.tags.extend(tags)
        db.session.commit()

    task = Task.query.options(joinedload(Task.tags)).get(task.id)
    return jsonify({
        "message": "Task created successfully",
        "task": task_schema.dump(task)
    }), 201


@task_bp.route('/<int:task_id>', methods=['PUT'])
@jwt_required()
@log_activity(
    activity_type=ActivityType.TASK_UPDATE,
    entity_type="task",
    get_entity_id="task_id"
)
def update_task(task_id):
    """Update a specific task."""
    current_user_id = get_jwt_identity()
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)

    task = Task.query.filter_by(id=task_id, user_id=current_user_id).first()
    if not task:
        return jsonify({"error": "Task not found"}), 404

    try:
        data = task_schema.load(request.json, partial=True)
    except ValidationError as err:
        return jsonify({"error": "Validation error",
                        "messages": err.messages}), 400

    for field in ('title', 'description', 'status',
                  'priority', 'due_date'):
        if field in data:
            setattr(task, field, data[field])

    # Tags
    if 'tag_ids' in data:
        task.tags = []
        if data['tag_ids']:
            tags = Tag.query.filter(
                Tag.id.in_(data['tag_ids']),
                Tag.user_id == current_user_id
            ).all()
            if len(tags) != len(data['tag_ids']):
                return jsonify({"error": "One or more tags not found"}), 404
            task.tags.extend(tags)

    db.session.commit()
    task = Task.query.options(joinedload(Task.tags)).get(task.id)
    return jsonify({
        "message": "Task updated successfully",
        "task": task_schema.dump(task)
    }), 200


@task_bp.route('/<int:task_id>', methods=['DELETE'])
@jwt_required()
@log_activity(
    activity_type=ActivityType.TASK_DELETE,
    entity_type="task",
    get_entity_id="task_id"
)
def delete_task(task_id):
    """Delete a specific task."""
    current_user_id = get_jwt_identity()
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)

    task = Task.query.filter_by(id=task_id, user_id=current_user_id).first()
    if not task:
        return jsonify({"error": "Task not found"}), 404

    db.session.delete(task)
    db.session.commit()
    return jsonify({"message": "Task deleted successfully"}), 200

# ---------------------------------------------------------------------- #
# Bulk operations – activity logged once per call
# ---------------------------------------------------------------------- #
@task_bp.route('/bulk/delete', methods=['POST'])
@jwt_required()
@log_activity(ActivityType.TASK_BULK_DELETE, entity_type="task")
def bulk_delete_tasks():
    """Delete multiple tasks."""
    current_user_id = get_jwt_identity()
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)

    try:
        data = task_bulk_delete_schema.load(request.json)
    except ValidationError as err:
        return jsonify({"error": "Validation error",
                        "messages": err.messages}), 400

    count = db.session.query(Task).filter(
        Task.id.in_(data['task_ids']),
        Task.user_id == current_user_id
    ).delete(synchronise_session=False)
    db.session.commit()

    return jsonify({"message": f"{count} tasks deleted successfully"}), 200


@task_bp.route('/bulk/update', methods=['PUT'])
@jwt_required()
@log_activity(ActivityType.TASK_BULK_UPDATE, entity_type="task")
def bulk_update_tasks():
    """Update multiple tasks."""
    current_user_id = get_jwt_identity()
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)

    try:
        data = task_bulk_update_schema.load(request.json)
    except ValidationError as err:
        return jsonify({"error": "Validation error",
                        "messages": err.messages}), 400

    valid_fields = {'status', 'priority', 'due_date'}
    if not set(data['updates']).issubset(valid_fields):
        return jsonify({"error": "Only status, priority or due_date "
                                 "can be mass-updated"}), 400

    tasks = Task.query.filter(
        Task.id.in_(data['task_ids']),
        Task.user_id == current_user_id
    ).all()

    for task in tasks:
        for field, value in data['updates'].items():
            setattr(task, field, value)

    db.session.commit()
    return jsonify({
        "message": f"{len(tasks)} tasks updated successfully"
    }), 200

### File: C:\Users\rdjon\task-management-api\app\resources\__init__.py


### File: C:\Users\rdjon\task-management-api\app\schemas\comment.py
from marshmallow import Schema, fields, validate, ValidationError

class CommentSchema(Schema):
    """Schema for validating and serializing comment data."""
    id = fields.Integer(dump_only=True)
    content = fields.String(required=True, validate=validate.Length(min=1))
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)
    task_id = fields.Integer(dump_only=True)
    user_id = fields.Integer(dump_only=True)
    # Add these fields for showing the username in comments
    username = fields.String(dump_only=True, attribute="user.username")

### File: C:\Users\rdjon\task-management-api\app\schemas\tag.py
from marshmallow import Schema, fields, validate, ValidationError

class TagSchema(Schema):
    """Schema for validating and serializing tag data."""
    id = fields.Integer(dump_only=True)
    name = fields.String(required=True, validate=validate.Length(min=1, max=50))
    color = fields.String(validate=validate.Regexp(r'^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$'))
    user_id = fields.Integer(dump_only=True)

class TagReferenceSchema(Schema):
    """Schema for referencing tags in other schemas."""
    id = fields.Integer(required=True)

### File: C:\Users\rdjon\task-management-api\app\schemas\task.py
from marshmallow import Schema, fields, validate, validates, ValidationError
from datetime import datetime
from app.schemas.tag import TagSchema

class TaskSchema(Schema):
    """Schema for validating and serializing task data."""
    id = fields.Integer(dump_only=True)
    title = fields.String(required=True, validate=validate.Length(min=1, max=100))
    description = fields.String()
    status = fields.String(validate=validate.OneOf(['pending', 'in_progress', 'completed']))
    priority = fields.String(validate=validate.OneOf(['low', 'medium', 'high']))
    due_date = fields.DateTime(format='iso')
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)
    user_id = fields.Integer(dump_only=True)
    tags = fields.Nested(TagSchema, many=True, dump_only=True)
    tag_ids = fields.List(fields.Integer(), load_only=True)
    
    @validates('due_date')
    def validate_due_date(self, value, **kwargs):
        """Validate that due_date is not in the past."""
        if value and value < datetime.utcnow():
            raise ValidationError('Due date cannot be in the past.')

class TaskQuerySchema(Schema):
    """Schema for validating task query parameters."""
    status = fields.String(validate=validate.OneOf(['pending', 'in_progress', 'completed']))
    priority = fields.String(validate=validate.OneOf(['low', 'medium', 'high']))
    search = fields.String()
    tag = fields.Integer()  # Tag ID to filter by
    due_before = fields.DateTime(format='iso')
    due_after = fields.DateTime(format='iso')
    sort_by = fields.String(validate=validate.OneOf(
        ['title', 'status', 'priority', 'due_date', 'created_at', 'updated_at']
    ))
    sort_order = fields.String(validate=validate.OneOf(['asc', 'desc']))
    page = fields.Integer(validate=validate.Range(min=1))
    per_page = fields.Integer(validate=validate.Range(min=1, max=100))

class TaskBulkDeleteSchema(Schema):
    """Schema for validating bulk delete data."""
    task_ids = fields.List(fields.Integer(), required=True, validate=validate.Length(min=1))

class TaskBulkUpdateSchema(Schema):
    """Schema for validating bulk update data."""
    task_ids = fields.List(fields.Integer(), required=True, validate=validate.Length(min=1))
    updates = fields.Dict(required=True)

### File: C:\Users\rdjon\task-management-api\app\schemas\user.py
from marshmallow import Schema, fields, validate, ValidationError

class UserRegistrationSchema(Schema):
    """Schema for validating user registration data."""
    username = fields.String(required=True, validate=validate.Length(min=3, max=80))
    email = fields.Email(required=True)
    password = fields.String(required=True, validate=validate.Length(min=8))
    role = fields.String(validate=validate.OneOf(['user', 'admin']))

class UserLoginSchema(Schema):
    """Schema for validating user login data."""
    email = fields.Email(required=True)
    password = fields.String(required=True)

class UserSchema(Schema):
    """Schema for serializing user data."""
    id = fields.Integer(dump_only=True)
    username = fields.String(dump_only=True)
    email = fields.Email(dump_only=True)
    role = fields.String(dump_only=True)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)

### File: C:\Users\rdjon\task-management-api\app\schemas\__init__.py
from app.schemas.user import UserRegistrationSchema, UserLoginSchema, UserSchema
from app.schemas.task import TaskSchema, TaskQuerySchema, TaskBulkDeleteSchema, TaskBulkUpdateSchema
from app.schemas.tag import TagSchema, TagReferenceSchema
from app.schemas.comment import CommentSchema

# Initialise schemas
user_schema = UserSchema()
users_schema = UserSchema(many=True)
user_registration_schema = UserRegistrationSchema()
user_login_schema = UserLoginSchema()

task_schema = TaskSchema()
tasks_schema = TaskSchema(many=True)
task_query_schema = TaskQuerySchema()
task_bulk_delete_schema = TaskBulkDeleteSchema()
task_bulk_update_schema = TaskBulkUpdateSchema()

tag_schema = TagSchema()
tags_schema = TagSchema(many=True)
tag_reference_schema = TagReferenceSchema()

comment_schema = CommentSchema()
comments_schema = CommentSchema(many=True)

### File: C:\Users\rdjon\task-management-api\app\utils\activity_logger.py
from functools import wraps
from flask import request, g
from flask_jwt_extended import get_jwt_identity
from app.models.activity_log import ActivityLog, ActivityType
from app import db

def log_activity(activity_type, entity_type=None, get_entity_id=None, description_template=None):
    """Decorator to log activities automatically."""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # Execute the wrapped function
            result = f(*args, **kwargs)
            
            # Only log if the operation was successful (2xx status code)
            if hasattr(result, 'status_code') and 200 <= result[1] < 300:
                try:
                    # Get current user ID
                    current_user_id = get_jwt_identity()
                    if isinstance(current_user_id, str):
                        current_user_id = int(current_user_id)
                    
                    # Get entity ID if provided
                    entity_id = None
                    if get_entity_id:
                        if callable(get_entity_id):
                            entity_id = get_entity_id(result, *args, **kwargs)
                        else:
                            entity_id = kwargs.get(get_entity_id)
                    
                    # Generate description
                    description = None
                    if description_template:
                        if callable(description_template):
                            description = description_template(result, *args, **kwargs)
                        else:
                            description = description_template.format(**kwargs)
                    
                    # Log the activity
                    ActivityLog.log(
                        user_id=current_user_id,
                        activity_type=activity_type,
                        entity_type=entity_type,
                        entity_id=entity_id,
                        description=description,
                        request=request
                    )
                    
                    # Commit as part of the same transaction
                    db.session.commit()
                    
                except Exception as e:
                    # Don't let logging errors break the application
                    print(f"Error logging activity: {str(e)}")
                    db.session.rollback()
            
            return result
        
        return decorated_function
    return decorator

def get_task_id_from_response(result, *args, **kwargs):
    """Extract task ID from response."""
    if 'task_id' in kwargs:
        return kwargs['task_id']
    try:
        data = result[0].get_json()
        if data and 'task' in data and 'id' in data['task']:
            return data['task']['id']
    except:
        pass
    return None

def get_tag_id_from_response(result, *args, **kwargs):
    """Extract tag ID from response."""
    if 'tag_id' in kwargs:
        return kwargs['tag_id']
    try:
        data = result[0].get_json()
        if data and 'tag' in data and 'id' in data['tag']:
            return data['tag']['id']
    except:
        pass
    return None

def get_comment_id_from_response(result, *args, **kwargs):
    """Extract comment ID from response."""
    if 'comment_id' in kwargs:
        return kwargs['comment_id']
    try:
        data = result[0].get_json()
        if data and 'comment' in data and 'id' in data['comment']:
            return data['comment']['id']
    except:
        pass
    return None

### File: C:\Users\rdjon\task-management-api\app\utils\api_docs.py
from flask import Blueprint, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.models.user import User

api_docs_bp = Blueprint('api_docs', __name__)

@api_docs_bp.route('', methods=['GET'])
def get_api_docs():
    """Get API documentation."""
    return jsonify({
        "api_version": "v1",
        "title": "Task Management API",
        "description": "A RESTful API for managing tasks",
        "endpoints": {
            "authentication": {
                "/api/v1/auth/register": {
                    "methods": ["POST"],
                    "description": "Register a new user"
                },
                "/api/v1/auth/login": {
                    "methods": ["POST"],
                    "description": "Login a user"
                },
                "/api/v1/auth/refresh": {
                    "methods": ["POST"],
                    "description": "Refresh access token"
                },
                "/api/v1/auth/logout": {
                    "methods": ["POST"],
                    "description": "Logout a user (revoke current token)"
                },
                "/api/v1/auth/logout/all": {
                    "methods": ["POST"],
                    "description": "Logout from all devices (revoke all tokens)"
                },
                "/api/v1/auth/me": {
                    "methods": ["GET", "PUT"],
                    "description": "Get or update current user details"
                }
            },
            "tasks": {
                "/api/v1/tasks": {
                    "methods": ["GET", "POST"],
                    "description": "Get all tasks or create a new task"
                },
                "/api/v1/tasks/<id>": {
                    "methods": ["GET", "PUT", "DELETE"],
                    "description": "Get, update or delete a specific task"
                },
                "/api/v1/tasks/bulk/delete": {
                    "methods": ["POST"],
                    "description": "Delete multiple tasks"
                },
                "/api/v1/tasks/bulk/update": {
                    "methods": ["PUT"],
                    "description": "Update multiple tasks"
                },
                "/api/v1/tasks/statistics": {
                    "methods": ["GET"],
                    "description": "Get task statistics"
                },
                "/api/v1/tasks/<id>/tags": {
                    "methods": ["POST"],
                    "description": "Add a tag to a task"
                },
                "/api/v1/tasks/<id>/tags/<tag_id>": {
                    "methods": ["DELETE"],
                    "description": "Remove a tag from a task"
                }
            },
            "tags": {
                "/api/v1/tags": {
                    "methods": ["GET", "POST"],
                    "description": "Get all tags or create a new tag"
                },
                "/api/v1/tags/<id>": {
                    "methods": ["GET", "PUT", "DELETE"],
                    "description": "Get, update or delete a specific tag"
                }
            },
            "comments": {
                "/api/v1/tasks/<id>/comments": {
                    "methods": ["GET", "POST"],
                    "description": "Get all comments for a task or create a new comment"
                },
                "/api/v1/comments/<id>": {
                    "methods": ["GET", "PUT", "DELETE"],
                    "description": "Get, update or delete a specific comment"
                }
            },
            "export": {
                "/api/v1/tasks/export": {
                    "methods": ["GET"],
                    "description": "Export tasks in different formats (json, csv)"
                }
            },
            "admin": {
                "/api/v1/admin/users": {
                    "methods": ["GET"],
                    "description": "Get all users (admin only)"
                },
                "/api/v1/admin/users/<id>": {
                    "methods": ["GET", "PUT", "DELETE"],
                    "description": "Get, update or delete a specific user (admin only)"
                },
                "/api/v1/admin/stats": {
                    "methods": ["GET"],
                    "description": "Get admin statistics (admin only)"
                }
            }
        }
    }), 200

@api_docs_bp.route('/user', methods=['GET'])
@jwt_required()
def get_user_api_docs():
    """Get API documentation with user role information."""
    current_user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(current_user_id, str):
        current_user_id = int(current_user_id)
    
    user = User.query.get(current_user_id)
    
    if not user:
        return jsonify({"error": "User not found"}), 404
    
    # Base documentation
    docs = get_api_docs().json
    
    # Add user role information
    docs["user"] = {
        "id": user.id,
        "username": user.username,
        "role": user.role
    }
    
    # Add role-specific information
    if user.role == 'admin':
        docs["admin_access"] = True
    else:
        docs["admin_access"] = False
    
    return jsonify(docs), 200

### File: C:\Users\rdjon\task-management-api\app\utils\auth.py
from functools import wraps
from flask import jsonify, request
from flask_jwt_extended import verify_jwt_in_request, get_jwt_identity
from app.models.user import User

def admin_required(fn):
    """
    Decorator for endpoints that require admin privileges.
    """
    @wraps(fn)
    def wrapper(*args, **kwargs):
        verify_jwt_in_request()
        user_id = get_jwt_identity()
        
        # Convert string ID back to integer if needed
        if isinstance(user_id, str):
            try:
                user_id = int(user_id)
            except ValueError:
                return jsonify({"error": "Invalid user ID"}), 400
            
        user = User.query.get(user_id)
        
        if not user:
            return jsonify({"error": "User not found"}), 404
        
        if user.role != 'admin':
            return jsonify({"error": "Admin privileges required"}), 403
        
        return fn(*args, **kwargs)
    
    return wrapper

def get_current_user():
    """
    Helper function to get the current authenticated user.
    """
    user_id = get_jwt_identity()
    
    # Convert string ID back to integer if needed
    if isinstance(user_id, str):
        try:
            user_id = int(user_id)
        except ValueError:
            return None
            
    return User.query.get(user_id)

def is_owner_or_admin(model_instance):
    """
    Check if the current user is the owner of the model instance or an admin.
    """
    user = get_current_user()
    
    if not user:
        return False
    
    # Check if user is admin
    if user.role == 'admin':
        return True
    
    # Check if user is owner (if the model has a user_id attribute)
    if hasattr(model_instance, 'user_id'):
        return model_instance.user_id == user.id
    
    return False

def owner_or_admin_required(model_class):
    """
    Decorator for endpoints that require the user to be owner or admin.
    """
    def decorator(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            verify_jwt_in_request()
            
            # Get ID from URL parameters
            id_param = None
            for name, value in kwargs.items():
                if name.endswith('_id'):
                    id_param = value
                    break
            
            if id_param is None:
                return jsonify({"error": "Resource ID not found in request"}), 400
            
            # Get model instance
            instance = model_class.query.get(id_param)
            
            if not instance:
                return jsonify({"error": "Resource not found"}), 404
            
            # Check if user is owner or admin
            if not is_owner_or_admin(instance):
                return jsonify({"error": "You don't have permission to access this resource"}), 403
            
            return fn(*args, **kwargs)
        
        return wrapper
    
    return decorator

### File: C:\Users\rdjon\task-management-api\app\utils\cleanup.py
from app import db
from app.models.token_blacklist import TokenBlacklist
from datetime import datetime, timezone
import logging

def cleanup_expired_tokens():
    """Remove expired tokens from the blacklist."""
    try:
        # Get current time
        now = datetime.now(timezone.utc)
        
        # Find expired tokens
        expired_tokens = TokenBlacklist.query.filter(TokenBlacklist.expires_at < now).all()
        
        if expired_tokens:
            # Delete expired tokens
            for token in expired_tokens:
                db.session.delete(token)
            
            # Commit changes
            db.session.commit()
            
            return len(expired_tokens)
        
        return 0
    except Exception as e:
        logging.error(f"Error cleaning up expired tokens: {str(e)}")
        db.session.rollback()
        return -1

### File: C:\Users\rdjon\task-management-api\app\utils\db_init.py
from app import db
from app.models.user import User
from app.models.task import Task
from sqlalchemy import text

def init_db():
    """Initialise database with tables."""
    # Create tables
    db.create_all()
    print("Database tables created.")

def drop_db():
    """Drop all database tables."""
    db.drop_all()
    print("Database tables dropped.")

def create_sample_data():
    """Create sample data for development."""
    # Create a regular user
    user = User(
        username="demo",
        email="demo@example.com",
        password="password123",
        role="user"
    )
    db.session.add(user)
    
    # Create an admin user
    admin = User(
        username="admin",
        email="admin@example.com",
        password="adminpassword",
        role="admin"
    )
    db.session.add(admin)
    
    db.session.commit()
    
    # Create sample tasks for regular user
    tasks = [
        Task(
            title="Complete project setup",
            description="Initialise the project structure and dependencies",
            status="completed",
            priority="high",
            user_id=user.id
        ),
        Task(
            title="Implement user authentication",
            description="Create login and registration endpoints",
            status="in_progress",
            priority="high",
            user_id=user.id
        ),
        Task(
            title="Design database schema",
            description="Create models for users and tasks",
            status="completed",
            priority="medium",
            user_id=user.id
        ),
        Task(
            title="Write API documentation",
            description="Document all API endpoints using Swagger",
            status="pending",
            priority="low",
            user_id=user.id
        )
    ]
    
    db.session.add_all(tasks)
    
    # Create sample tasks for admin user
    admin_tasks = [
        Task(
            title="Review security policies",
            description="Ensure all endpoints have proper authorisation",
            status="pending",
            priority="high",
            user_id=admin.id
        ),
        Task(
            title="Deploy to production",
            description="Prepare and deploy the app to production server",
            status="pending",
            priority="medium",
            user_id=admin.id
        )
    ]
    
    db.session.add_all(admin_tasks)
    db.session.commit()
    
    print(f"Created regular user: {user.username}")
    print(f"Created admin user: {admin.username}")
    print(f"Created {len(tasks)} tasks for regular user")
    print(f"Created {len(admin_tasks)} tasks for admin user")

### File: C:\Users\rdjon\task-management-api\app\utils\email.py
import os
from flask import current_app, render_template_string
from flask_mail import Mail, Message
from threading import Thread

mail = Mail()

def send_async_email(app, msg):
    """Send email asynchronously."""
    with app.app_context():
        mail.send(msg)

def send_email(subject, recipient, body, html_body=None):
    """Send an email."""
    app = current_app._get_current_object()
    msg = Message(
        subject=subject,
        sender=app.config.get('MAIL_DEFAULT_SENDER', 'noreply@taskmanager.com'),
        recipients=[recipient]
    )
    msg.body = body
    if html_body:
        msg.html = html_body
    
    # Send email in background thread
    Thread(target=send_async_email, args=(app, msg)).start()

def send_password_reset_email(user, token):
    """Send password reset email to user."""
    reset_url = f"{current_app.config.get('FRONTEND_URL', 'http://localhost:3000')}/reset-password?token={token}"
    
    subject = "Password Reset Request - Task Manager"
    
    body = f"""
Dear {user.username},

You have requested to reset your password for your Task Manager account.

Please click the following link to reset your password:
{reset_url}

This link will expire in 24 hours.

If you did not request this password reset, please ignore this email and your password will remain unchanged.

Best regards,
The Task Manager Team
"""
    
    html_body = f"""
<html>
<body>
    <h2>Password Reset Request</h2>
    <p>Dear {user.username},</p>
    <p>You have requested to reset your password for your Task Manager account.</p>
    <p>Please click the button below to reset your password:</p>
    <p style="margin: 30px 0;">
        <a href="{reset_url}" style="background-color: #3498db; color: white; padding: 12px 30px; text-decoration: none; border-radius: 4px;">
            Reset Password
        </a>
    </p>
    <p>Or copy and paste this link into your browser:</p>
    <p style="color: #666; word-break: break-all;">{reset_url}</p>
    <p><strong>This link will expire in 24 hours.</strong></p>
    <p>If you did not request this password reset, please ignore this email and your password will remain unchanged.</p>
    <p>Best regards,<br>The Task Manager Team</p>
</body>
</html>
"""
    
    send_email(subject, user.email, body, html_body)

def send_password_reset_confirmation_email(user):
    """Send password reset confirmation email."""
    subject = "Password Reset Successful - Task Manager"
    
    body = f"""
Dear {user.username},

Your password has been successfully reset.

If you did not make this change, please contact our support team immediately.

Best regards,
The Task Manager Team
"""
    
    html_body = f"""
<html>
<body>
    <h2>Password Reset Successful</h2>
    <p>Dear {user.username},</p>
    <p>Your password has been successfully reset.</p>
    <p>If you did not make this change, please contact our support team immediately.</p>
    <p>Best regards,<br>The Task Manager Team</p>
</body>
</html>
"""
    
    send_email(subject, user.email, body, html_body)

### File: C:\Users\rdjon\task-management-api\app\utils\errors.py
### File: C:\Users\rdjon\Downloads\task-management-api\app\utils\errors.py
from flask import jsonify
from marshmallow import ValidationError

def register_error_handlers(app):
    """Register error handlers for the application."""
    
    @app.errorhandler(400)
    def bad_request(e):
        return jsonify({"error": "Bad request", "message": str(e)}), 400
    
    @app.errorhandler(401)
    def unauthorized(e):
        return jsonify({"error": "Unauthorised", "message": str(e)}), 401
    
    @app.errorhandler(403)
    def forbidden(e):
        return jsonify({"error": "Forbidden", "message": str(e)}), 403
    
    @app.errorhandler(404)
    def not_found(e):
        return jsonify({"error": "Not found", "message": str(e)}), 404
    
    @app.errorhandler(405)
    def method_not_allowed(e):
        return jsonify({"error": "Method not allowed", "message": str(e)}), 405
    
    @app.errorhandler(500)
    def server_error(e):
        return jsonify({"error": "Server error", "message": str(e)}), 500
    
    @app.errorhandler(ValidationError)
    def validation_error(e):
        return jsonify({"error": "Validation error", "messages": e.messages}), 400

def handle_exception(e):
    """Handle and format exceptions."""
    if isinstance(e, ValidationError):
        return jsonify({"error": "Validation error", "messages": e.messages}), 400
    
    return jsonify({"error": "An error occurred", "message": str(e)}), 500

### File: C:\Users\rdjon\task-management-api\app\utils\helpers.py
from functools import wraps
from flask import jsonify
from flask_jwt_extended import verify_jwt_in_request, get_jwt_identity

def admin_required(fn):
    """
    Decorator for endpoints that require admin privileges.
    Note: Admin functionality is not implemented in this phase.
    """
    @wraps(fn)
    def wrapper(*args, **kwargs):
        # Implementation will be done if needed in later phases
        pass
    
    return wrapper

# Additional helper functions will be added as needed

### File: C:\Users\rdjon\task-management-api\app\utils\__init__.py
from flask import Flask, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_jwt_extended import JWTManager
from flask_cors import CORS
import os

# Initialise extensions
db = SQLAlchemy()
migrate = Migrate()
jwt = JWTManager()
cors = CORS()

def create_app(config_object='app.config.DevelopmentConfig'):
    """Application factory pattern.
    
    Args:
        config_object (str): The configuration object to use.
        
    Returns:
        app: Flask application instance
    """
    app = Flask(__name__)
    app.config.from_object(config_object)
    
    # Initialise extensions with app
    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    cors.init_app(app)
    
    # Register blueprints
    from app.resources.auth import auth_bp
    from app.resources.task import task_bp
    from app.utils.api_docs import api_docs_bp
    
    app.register_blueprint(auth_bp, url_prefix='/api/v1/auth')
    app.register_blueprint(task_bp, url_prefix='/api/v1/tasks')
    app.register_blueprint(api_docs_bp, url_prefix='/api/v1/docs')
    
    # Register CLI commands
    from app.cli import register_commands
    register_commands(app)
    
    # Register error handlers
    from app.utils.errors import register_error_handlers
    register_error_handlers(app)
    
    # JWT error handlers
    @jwt.expired_token_loader
    def expired_token_callback(jwt_header, jwt_payload):
        return jsonify({
            'error': 'Token has expired',
            'message': 'Please log in again'
        }), 401
    
    @jwt.invalid_token_loader
    def invalid_token_callback(error):
        return jsonify({
            'error': 'Invalid token',
            'message': 'Signature verification failed'
        }), 401
    
    @jwt.unauthorized_loader
    def missing_token_callback(error):
        return jsonify({
            'error': 'Authorisation required',
            'message': 'Token is missing'
        }), 401
    
    # Shell context for flask cli
    @app.shell_context_processor
    def ctx():
        return {"app": app, "db": db}
    
    # Root route
    @app.route('/')
    def index():
        return jsonify({
            "message": "Welcome to the Task Management API",
            "version": "1.0.0",
            "documentation": "/api/v1/docs"
        }), 200
    
    return app

### File: C:\Users\rdjon\task-management-api\migrations\alembic.ini
# A generic, single database configuration.

[alembic]
# template used to generate migration files
# file_template = %%(rev)s_%%(slug)s

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false


# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic,flask_migrate

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[logger_flask_migrate]
level = INFO
handlers =
qualname = flask_migrate

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


### File: C:\Users\rdjon\task-management-api\migrations\env.py
import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


### File: C:\Users\rdjon\task-management-api\migrations\versions\59449644591f_add_tag_and_comment_models.py
"""Add tag and comment models

Revision ID: 59449644591f
Revises: 883ce3c7349f
Create Date: 2025-05-08 19:31:24.663156

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '59449644591f'
down_revision = '883ce3c7349f'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('tags',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=50), nullable=False),
    sa.Column('color', sa.String(length=7), nullable=True),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name')
    )
    op.create_table('comments',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('content', sa.Text(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.Column('task_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['task_id'], ['tasks.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('task_tags',
    sa.Column('task_id', sa.Integer(), nullable=False),
    sa.Column('tag_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['tag_id'], ['tags.id'], ),
    sa.ForeignKeyConstraint(['task_id'], ['tasks.id'], ),
    sa.PrimaryKeyConstraint('task_id', 'tag_id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('task_tags')
    op.drop_table('comments')
    op.drop_table('tags')
    # ### end Alembic commands ###


### File: C:\Users\rdjon\task-management-api\migrations\versions\883ce3c7349f_add_role_field_to_user_model_and_create_.py
"""Add role field to User model and create TokenBlacklist model

Revision ID: 883ce3c7349f
Revises: f70fa4f69e9d
Create Date: 2025-05-08 17:25:08.116167

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '883ce3c7349f'
down_revision = 'f70fa4f69e9d'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('token_blacklist',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('jti', sa.String(length=36), nullable=False),
    sa.Column('token_type', sa.String(length=10), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('revoked_at', sa.DateTime(), nullable=False),
    sa.Column('expires_at', sa.DateTime(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('jti')
    )
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.add_column(sa.Column('role', sa.String(length=20), server_default='user', nullable=False))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.drop_column('role')

    op.drop_table('token_blacklist')
    # ### end Alembic commands ###


### File: C:\Users\rdjon\task-management-api\migrations\versions\e5376396980d_add_password_reset_tokens_and_activity_.py
"""Add password reset tokens and activity logs

Revision ID: e5376396980d
Revises: 59449644591f
Create Date: 2025-05-23 22:40:58.247510

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'e5376396980d'
down_revision = '59449644591f'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('activity_logs',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('activity_type', sa.String(length=50), nullable=False),
    sa.Column('entity_type', sa.String(length=50), nullable=True),
    sa.Column('entity_id', sa.Integer(), nullable=True),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('activity_data', sa.JSON(), nullable=True),
    sa.Column('ip_address', sa.String(length=45), nullable=True),
    sa.Column('user_agent', sa.String(length=256), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('activity_logs', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_activity_logs_activity_type'), ['activity_type'], unique=False)
        batch_op.create_index(batch_op.f('ix_activity_logs_created_at'), ['created_at'], unique=False)

    op.create_table('password_reset_tokens',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('token', sa.String(length=100), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('expires_at', sa.DateTime(), nullable=False),
    sa.Column('used', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('password_reset_tokens', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_password_reset_tokens_token'), ['token'], unique=True)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('password_reset_tokens', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_password_reset_tokens_token'))

    op.drop_table('password_reset_tokens')
    with op.batch_alter_table('activity_logs', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_activity_logs_created_at'))
        batch_op.drop_index(batch_op.f('ix_activity_logs_activity_type'))

    op.drop_table('activity_logs')
    # ### end Alembic commands ###


### File: C:\Users\rdjon\task-management-api\migrations\versions\f70fa4f69e9d_initial_migration.py
"""Initial migration

Revision ID: f70fa4f69e9d
Revises: 
Create Date: 2025-05-08 16:47:54.080064

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'f70fa4f69e9d'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('username', sa.String(length=80), nullable=False),
    sa.Column('email', sa.String(length=120), nullable=False),
    sa.Column('password_hash', sa.String(length=256), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_users_email'), ['email'], unique=True)
        batch_op.create_index(batch_op.f('ix_users_username'), ['username'], unique=True)

    op.create_table('tasks',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('title', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('status', sa.String(length=20), nullable=True),
    sa.Column('priority', sa.String(length=20), nullable=True),
    sa.Column('due_date', sa.DateTime(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('tasks', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_tasks_due_date'), ['due_date'], unique=False)
        batch_op.create_index(batch_op.f('ix_tasks_priority'), ['priority'], unique=False)
        batch_op.create_index(batch_op.f('ix_tasks_status'), ['status'], unique=False)
        batch_op.create_index(batch_op.f('ix_tasks_user_id'), ['user_id'], unique=False)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('tasks', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_tasks_user_id'))
        batch_op.drop_index(batch_op.f('ix_tasks_status'))
        batch_op.drop_index(batch_op.f('ix_tasks_priority'))
        batch_op.drop_index(batch_op.f('ix_tasks_due_date'))

    op.drop_table('tasks')
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_users_username'))
        batch_op.drop_index(batch_op.f('ix_users_email'))

    op.drop_table('users')
    # ### end Alembic commands ###


### File: C:\Users\rdjon\task-management-api\task-manager-frontend\index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Manager</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="shortcut icon" href="assets/favicon.ico" type="image/x-icon">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="app-container">
        <header>
            <h1>Task Manager</h1>
            <div class="user-info">
                <span id="username">Loading...</span>
                <button id="logout-btn" class="btn btn-outline"><i class="fas fa-sign-out-alt"></i> Logout</button>
            </div>
        </header>

        <main>
            <div class="sidebar">
                <div class="filters">
                    <h2>Filters</h2>
                    <div class="filter-group">
                        <label for="status-filter">Status:</label>
                        <select id="status-filter">
                            <option value="">All</option>
                            <option value="pending">Pending</option>
                            <option value="in_progress">In Progress</option>
                            <option value="completed">Completed</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="priority-filter">Priority:</label>
                        <select id="priority-filter">
                            <option value="">All</option>
                            <option value="low">Low</option>
                            <option value="medium">Medium</option>
                            <option value="high">High</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="tag-filter">Tag:</label>
                        <select id="tag-filter">
                            <option value="">All</option>
                            <!-- Tags will be loaded dynamically -->
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="search-input">Search:</label>
                        <input type="text" id="search-input" placeholder="Search tasks...">
                    </div>
                    <button id="apply-filters-btn" class="btn btn-primary">Apply Filters</button>
                </div>

                <div class="tags-section">
                    <h2>Tags</h2>
                    <div id="tags-list" class="tags-list">
                        <!-- Tags will be loaded dynamically -->
                    </div>
                    <div class="add-tag-form">
                        <input type="text" id="new-tag-name" placeholder="New tag name" maxlength="50">
                        <input type="color" id="new-tag-color" value="#3498db" title="Choose tag color">
                        <button id="add-tag-btn" class="btn btn-small">Add</button>
                    </div>
                    <div class="help-text">Tags help organise your tasks</div>
                </div>

                <div class="statistics">
                    <h2>Statistics</h2>
                    <div id="statistics-content">
                        <!-- Statistics will be loaded dynamically -->
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="tasks-header">
                    <h2>My Tasks</h2>
                    <button id="new-task-btn" class="btn btn-primary"><i class="fas fa-plus"></i> New Task</button>
                </div>

                <div id="tasks-container" class="tasks-container">
                    <!-- Tasks will be loaded dynamically -->
                    <div class="loading">Loading tasks...</div>
                </div>

                <div class="pagination">
                    <button id="prev-page-btn" class="btn btn-outline" disabled><i class="fas fa-chevron-left"></i> Previous</button>
                    <span id="pagination-info">Page 1 of 1</span>
                    <button id="next-page-btn" class="btn btn-outline" disabled>Next <i class="fas fa-chevron-right"></i></button>
                </div>
            </div>
        </main>
    </div>

    <!-- Task Modal -->
    <div id="task-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">New Task</h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <form id="task-form">
                    <input type="hidden" id="task-id">
                    <div class="form-group">
                        <label for="task-title">Title:</label>
                        <input type="text" id="task-title" required maxlength="100">
                    </div>
                    <div class="form-group">
                        <label for="task-description">Description:</label>
                        <textarea id="task-description" rows="3"></textarea>
                    </div>
                    <div class="form-row">
                        <div class="form-group half">
                            <label for="task-status">Status:</label>
                            <select id="task-status">
                                <option value="pending">Pending</option>
                                <option value="in_progress">In Progress</option>
                                <option value="completed">Completed</option>
                            </select>
                        </div>
                        <div class="form-group half">
                            <label for="task-priority">Priority:</label>
                            <select id="task-priority">
                                <option value="low">Low</option>
                                <option value="medium">Medium</option>
                                <option value="high">High</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="task-due-date">Due Date:</label>
                        <input type="datetime-local" id="task-due-date">
                        <div class="help-text">Optional: Set a deadline for this task</div>
                    </div>
                    <div class="form-group">
                        <label>Tags:</label>
                        <div id="task-tags" class="task-tags-selection">
                            <!-- Tags will be loaded dynamically -->
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" id="cancel-task-btn" class="btn btn-outline">Cancel</button>
                        <button type="submit" id="save-task-btn" class="btn btn-primary">Save</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Comment Modal -->
    <div id="comment-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Task Comments</h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="task-details">
                    <h3 id="comment-task-title">Task Title</h3>
                    <p id="comment-task-description">Task Description</p>
                </div>
                <div id="comments-container" class="comments-container">
                    <!-- Comments will be loaded dynamically -->
                </div>
                <div class="add-comment">
                    <h4>Add Comment</h4>
                    <form id="comment-form">
                        <input type="hidden" id="comment-task-id">
                        <textarea id="comment-content" rows="3" required placeholder="Write your comment here..."></textarea>
                        <button type="submit" class="btn btn-primary">Add Comment</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <script src="js/feedback.js"></script>
    <script src="js/api.js"></script>
    <script src="js/auth.js"></script>
    <script src="js/tags.js"></script>
    <script src="js/tasks.js"></script>
    <script src="js/comments.js"></script>
</body>
</html>

### File: C:\Users\rdjon\task-management-api\task-manager-frontend\login.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login - Task Manager</title>
    <link rel="stylesheet" href="css/auth.css">
    <link rel="shortcut icon" href="assets/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="auth-container">
        <div class="auth-form">
            <h1>Task Manager</h1>
            <h2>Login</h2>
            
            <div id="error-message" class="error-message"></div>
            
            <form id="login-form">
                <div class="form-group">
                    <label for="email">Email:</label>
                    <input type="email" id="email" name="email" required>
                </div>
                <div class="form-group">
                    <label for="password">Password:</label>
                    <input type="password" id="password" name="password" required>
                </div>
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Login</button>
                </div>
            </form>
            
            <div class="auth-links">
                <p>Don't have an account? <a href="register.html">Register</a></p>
            </div>
        </div>
    </div>

    <script src="js/api.js"></script>
    <script src="js/auth.js"></script>
</body>
</html>

### File: C:\Users\rdjon\task-management-api\task-manager-frontend\register.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Register - Task Manager</title>
    <link rel="stylesheet" href="css/auth.css">
    <link rel="shortcut icon" href="assets/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="auth-container">
        <div class="auth-form">
            <h1>Task Manager</h1>
            <h2>Register</h2>
            
            <div id="error-message" class="error-message"></div>
            
            <form id="register-form">
                <div class="form-group">
                    <label for="username">Username:</label>
                    <input type="text" id="username" name="username" required>
                </div>
                <div class="form-group">
                    <label for="email">Email:</label>
                    <input type="email" id="email" name="email" required>
                </div>
                <div class="form-group">
                    <label for="password">Password:</label>
                    <input type="password" id="password" name="password" required>
                </div>
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Register</button>
                </div>
            </form>
            
            <div class="auth-links">
                <p>Already have an account? <a href="login.html">Login</a></p>
            </div>
        </div>
    </div>

    <script src="js/api.js"></script>
    <script src="js/auth.js"></script>
</body>
</html>

### File: C:\Users\rdjon\task-management-api\task-manager-frontend\css\auth.css
/* Base styles */
:root {
    --primary-color: #3498db;
    --primary-dark: #2980b9;
    --secondary-color: #e74c3c;
    --light-color: #f4f4f4;
    --dark-color: #333;
    --success-color: #2ecc71;
    --box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
    --border-radius: 4px;
    --transition: all 0.3s ease;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
    background-color: #f9f9f9;
    color: var(--dark-color);
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

.auth-container {
    width: 100%;
    max-width: 400px;
    padding: 1rem;
}

.auth-form {
    background-color: white;
    padding: 2rem;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
}

h1 {
    color: var(--primary-color);
    text-align: center;
    margin-bottom: 0.5rem;
}

h2 {
    text-align: center;
    margin-bottom: 1.5rem;
    color: var(--dark-color);
}

.form-group {
    margin-bottom: 1.5rem;
}

.form-group label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 500;
}

.form-group input {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #ddd;
    border-radius: var(--border-radius);
    font-size: 1rem;
}

.form-actions {
    margin-top: 1.5rem;
}

.btn {
    display: inline-block;
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 1rem;
    transition: var(--transition);
    width: 100%;
}

.btn-primary {
    background-color: var(--primary-color);
    color: white;
}

.btn-primary:hover {
    background-color: var(--primary-dark);
}

.auth-links {
    text-align: center;
    margin-top: 1.5rem;
}

.auth-links a {
    color: var(--primary-color);
    text-decoration: none;
}

.auth-links a:hover {
    text-decoration: underline;
}

.error-message {
    background-color: #f8d7da;
    color: #721c24;
    padding: 0.75rem;
    margin-bottom: 1rem;
    border-radius: var(--border-radius);
    display: none;
}

### File: C:\Users\rdjon\task-management-api\task-manager-frontend\css\style.css
/* Base styles */
:root {
    --primary-color: #3498db;
    --primary-dark: #2980b9;
    --secondary-color: #e74c3c;
    --light-color: #f4f4f4;
    --dark-color: #333;
    --success-color: #2ecc71;
    --warning-color: #f39c12;
    --danger-color: #e74c3c;
    --box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
    --border-radius: 4px;
    --transition: all 0.3s ease;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
    background-color: #f9f9f9;
    color: var(--dark-color);
}

.app-container {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
}

/* Header */
header {
    background-color: var(--primary-color);
    color: white;
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: var(--box-shadow);
}

.user-info {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.user-info span {
    font-weight: 500;
}

/* Main content */
main {
    display: flex;
    flex: 1;
    padding: 1rem;
    gap: 1rem;
}

/* Sidebar */
.sidebar {
    width: 300px;
    background-color: white;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
}

.filters h2, .tags-section h2, .statistics h2 {
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid #eee;
}

.filter-group {
    margin-bottom: 1rem;
}

.filter-group label {
    display: block;
    margin-bottom: 0.25rem;
    font-weight: 500;
}

.filter-group select, .filter-group input {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: var(--border-radius);
    font-size: 1rem;
}

/* Tags section */
.tags-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.tag {
    display: inline-flex;
    align-items: center;
    padding: 0.25rem 0.5rem;
    border-radius: 20px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: var(--transition);
}

.tag:hover {
    opacity: 0.8;
}

.tag i {
    margin-left: 0.5rem;
    cursor: pointer;
}

.tag-selected {
    box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.2);
}

.add-tag-form {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.add-tag-form input[type="text"] {
    flex: 1;
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: var(--border-radius);
}

.add-tag-form input[type="color"] {
    padding: 0;
    width: 2.5rem;
    height: 2.5rem;
    border: 1px solid #ddd;
    border-radius: var(--border-radius);
    cursor: pointer;
}

/* Statistics */
.statistics-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
}

/* Content */
.content {
    flex: 1;
    background-color: white;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    padding: 1rem;
}

.tasks-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid #eee;
}

/* Tasks */
.tasks-container {
    min-height: 200px;
    position: relative;
}

.task-card {
    background-color: #f9f9f9;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    margin-bottom: 1rem;
    transition: var(--transition);
}

.task-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
}

.task-header {
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #eee;
}

.task-title {
    font-size: 1.2rem;
    font-weight: 500;
}

.task-status {
    padding: 0.25rem 0.5rem;
    border-radius: 20px;
    font-size: 0.8rem;
    color: white;
}

.task-status.pending {
    background-color: var(--warning-color);
}

.task-status.in_progress {
    background-color: var(--primary-color);
}

.task-status.completed {
    background-color: var(--success-color);
}

.task-body {
    padding: 1rem;
}

.task-description {
    margin-bottom: 1rem;
    color: #666;
}

.task-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.9rem;
    color: #888;
}

.task-priority {
    display: inline-block;
    margin-right: 1rem;
}

.task-priority.high {
    color: var(--danger-color);
}

.task-priority.medium {
    color: var(--warning-color);
}

.task-priority.low {
    color: var(--success-color);
}

.task-due-date {
    margin-right: 1rem;
}

.task-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.5rem;
}

.task-footer {
    padding: 0.5rem 1rem;
    border-top: 1px solid #eee;
    display: flex;
    justify-content: space-between;
}

.task-actions {
    display: flex;
    gap: 0.5rem;
}

.task-comments {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    color: #888;
    cursor: pointer;
}

.task-comments:hover {
    color: var(--primary-color);
}

/* Pagination */
.pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    margin-top: 1rem;
}

/* Loading */
.loading {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 200px;
    color: #888;
}

/* Modal */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    overflow: auto;
}

.modal-content {
    background-color: white;
    margin: 5% auto;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    width: 600px;
    max-width: 90%;
    animation: modalOpen 0.3s;
}

@keyframes modalOpen {
    from { opacity: 0; transform: translateY(-50px); }
    to { opacity: 1; transform: translateY(0); }
}

.modal-header {
    padding: 1rem;
    border-bottom: 1px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.close {
    font-size: 1.5rem;
    cursor: pointer;
}

.close:hover {
    color: var(--danger-color);
}

.modal-body {
    padding: 1rem;
}

.modal-footer {
    padding-top: 1rem;
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
}

/* Form Elements */
.form-group {
    margin-bottom: 1rem;
}

.form-row {
    display: flex;
    gap: 1rem;
}

.form-group.half {
    width: 50%;
}

.form-group label {
    display: block;
    margin-bottom: 0.25rem;
    font-weight: 500;
}

.form-group input, .form-group select, .form-group textarea {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: var(--border-radius);
    font-size: 1rem;
}

.task-tags-selection {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.task-tag-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

/* Comments */
.task-details {
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid #eee;
}

.comments-container {
    margin-bottom: 1rem;
    max-height: 300px;
    overflow-y: auto;
}

.comment {
    background-color: #f9f9f9;
    border-radius: var(--border-radius);
    padding: 0.75rem;
    margin-bottom: 0.75rem;
}

.comment-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
    color: #888;
}

.comment-actions {
    display: flex;
    gap: 0.5rem;
}

.add-comment h4 {
    margin-bottom: 0.5rem;
}

.add-comment textarea {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: var(--border-radius);
    margin-bottom: 0.5rem;
    font-size: 1rem;
}

/* Buttons */
.btn {
    display: inline-block;
    padding: 0.5rem 1rem;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 1rem;
    transition: var(--transition);
}

.btn-primary {
    background-color: var(--primary-color);
    color: white;
}

.btn-primary:hover {
    background-color: var(--primary-dark);
}

.btn-danger {
    background-color: var(--danger-color);
    color: white;
}

.btn-danger:hover {
    background-color: #c0392b;
}

.btn-success {
    background-color: var(--success-color);
    color: white;
}

.btn-success:hover {
    background-color: #27ae60;
}

.btn-outline {
    background-color: transparent;
    border: 1px solid #ddd;
}

.btn-outline:hover {
    background-color: #f1f1f1;
}

.btn-small {
    padding: 0.25rem 0.5rem;
    font-size: 0.85rem;
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Error message */
.error-message {
    background-color: #f8d7da;
    color: #721c24;
    padding: 0.5rem;
    margin-bottom: 1rem;
    border-radius: var(--border-radius);
    display: none;
}

/* Toast notifications */
.toast {
    position: fixed;
    top: 20px;
    right: 20px;
    background: white;
    padding: 1rem 1.5rem;
    border-radius: var(--border-radius);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    display: flex;
    align-items: center;
    gap: 0.75rem;
    transform: translateX(400px);
    transition: transform 0.3s ease;
    z-index: 1001;
    max-width: 400px;
}

.toast.show {
    transform: translateX(0);
}

.toast-success {
    border-left: 4px solid var(--success-color);
}

.toast-success i {
    color: var(--success-color);
}

.toast-error {
    border-left: 4px solid var(--danger-color);
}

.toast-error i {
    color: var(--danger-color);
}

/* Field errors */
.field-error {
    color: var(--danger-color);
    font-size: 0.875rem;
    margin-top: 0.25rem;
}

input.error, select.error, textarea.error {
    border-color: var(--danger-color);
}

/* Confirmation modal */
.confirmation-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1002;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.confirmation-modal.show {
    opacity: 1;
}

.confirmation-content {
    background: white;
    padding: 2rem;
    border-radius: var(--border-radius);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    max-width: 400px;
    width: 90%;
}

.confirmation-content h3 {
    margin-bottom: 1rem;
}

.confirmation-content p {
    margin-bottom: 1.5rem;
    color: #666;
}

.confirmation-buttons {
    display: flex;
    gap: 1rem;
    justify-content: flex-end;
}

/* Loading states */
.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
}

/* Empty states */
.empty-state {
    text-align: center;
    padding: 3rem;
    color: #666;
}

.empty-state i {
    font-size: 3rem;
    color: #ddd;
    margin-bottom: 1rem;
}

.empty-state h3 {
    margin-bottom: 0.5rem;
}

.empty-state p {
    margin-bottom: 1.5rem;
}

/* Help text */
.help-text {
    font-size: 0.875rem;
    color: #666;
    margin-top: 0.25rem;
}

/* Progress indicator */
.progress-bar {
    height: 4px;
    background: #eee;
    border-radius: 2px;
    overflow: hidden;
    margin: 1rem 0;
}

.progress-fill {
    height: 100%;
    background: var(--primary-color);
    transition: width 0.3s ease;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    main {
        flex-direction: column;
    }

    .sidebar {
        width: 100%;
        margin-bottom: 1rem;
    }

    .form-row {
        flex-direction: column;
    }

    .form-group.half {
        width: 100%;
    }
}

### File: C:\Users\rdjon\task-management-api\task-manager-frontend\js\api.js
// API base URL - change this to your API endpoint
const API_BASE_URL = 'http://localhost:5000/api/v1';

// API service for making requests
const api = {
    // Set auth token
    setToken(token) {
        localStorage.setItem('accessToken', token);
    },

    // Get auth token
    getToken() {
        return localStorage.getItem('accessToken');
    },

    // Remove auth token
    removeToken() {
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        localStorage.removeItem('user');
    },

    // Save refresh token
    setRefreshToken(token) {
        localStorage.setItem('refreshToken', token);
    },

    // Get refresh token
    getRefreshToken() {
        return localStorage.getItem('refreshToken');
    },

    // Save user data
    setUser(user) {
        localStorage.setItem('user', JSON.stringify(user));
    },

    // Get user data
    getUser() {
        const user = localStorage.getItem('user');
        return user ? JSON.parse(user) : null;
    },

    // Check if user is authenticated
    isAuthenticated() {
        return !!this.getToken();
    },

    // Common fetch method with auth
    async fetch(endpoint, options = {}) {
        const token = this.getToken();
        
        const defaultOptions = {
            headers: {
                'Content-Type': 'application/json',
                ...(token ? { 'Authorization': `Bearer ${token}` } : {})
            }
        };

        const fetchOptions = {
            ...defaultOptions,
            ...options,
            headers: {
                ...defaultOptions.headers,
                ...options.headers
            }
        };

        try {
            const response = await fetch(`${API_BASE_URL}${endpoint}`, fetchOptions);
            
            // Handle rate limiting
            if (response.status === 429) {
                const retryAfter = response.headers.get('X-RateLimit-Reset') || '60';
                throw new Error(`Rate limit exceeded. Please wait ${retryAfter} seconds before trying again.`);
            }
            
            // Handle token expiration
            if (response.status === 401) {
                const responseBody = await response.json();
                // Only try refresh if it's an expired token
                if (responseBody.error === 'Token has expired') {
                    try {
                        const refreshed = await this.refreshToken();
                        if (refreshed) {
                            // Retry the original request with the new token
                            fetchOptions.headers['Authorization'] = `Bearer ${this.getToken()}`;
                            return fetch(`${API_BASE_URL}${endpoint}`, fetchOptions);
                        }
                    } catch (refreshError) {
                        // If refresh fails, logout and redirect to login
                        this.removeToken();
                        window.location.href = '/login.html';
                        throw new Error('Session expired. Please log in again.');
                    }
                }
            }
            
            // Regular response handling
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || errorData.message || 'Something went wrong');
            }
            
            // If the response is 204 No Content, return null
            if (response.status === 204) {
                return null;
            }
            
            return await response.json();
        } catch (error) {
            // Handle network errors
            if (error instanceof TypeError && error.message === 'Failed to fetch') {
                throw new Error('NetworkError: Unable to connect to the server');
            }
            console.error('API Error:', error);
            throw error;
        }
    },

    // Refresh token
    async refreshToken() {
        const refreshToken = this.getRefreshToken();
        if (!refreshToken) {
            return false;
        }

        try {
            const response = await fetch(`${API_BASE_URL}/auth/refresh`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${refreshToken}`
                }
            });

            if (!response.ok) {
                throw new Error('Token refresh failed');
            }

            const data = await response.json();
            this.setToken(data.access_token);
            return true;
        } catch (error) {
            console.error('Token refresh error:', error);
            return false;
        }
    },

    // Auth endpoints
    auth: {
        async login(email, password) {
            return api.fetch('/auth/login', {
                method: 'POST',
                body: JSON.stringify({ email, password })
            });
        },

        async register(username, email, password) {
            return api.fetch('/auth/register', {
                method: 'POST',
                body: JSON.stringify({ username, email, password })
            });
        },

        async logout() {
            try {
                await api.fetch('/auth/logout', { method: 'POST' });
            } finally {
                // Always clear local storage even if API call fails
                api.removeToken();
            }
        },

        async getProfile() {
            return api.fetch('/auth/me');
        }
    },

    // Task endpoints
    tasks: {
        async getAll(params = {}) {
            const queryParams = new URLSearchParams();
            
            // Add all params to query string
            Object.entries(params).forEach(([key, value]) => {
                if (value !== undefined && value !== null && value !== '') {
                    queryParams.append(key, value);
                }
            });
            
            const queryString = queryParams.toString() ? `?${queryParams.toString()}` : '';
            return api.fetch(`/tasks${queryString}`);
        },

        async getById(id) {
            return api.fetch(`/tasks/${id}`);
        },

        async create(taskData) {
            return api.fetch('/tasks', {
                method: 'POST',
                body: JSON.stringify(taskData)
            });
        },

        async update(id, taskData) {
            return api.fetch(`/tasks/${id}`, {
                method: 'PUT',
                body: JSON.stringify(taskData)
            });
        },

        async delete(id) {
            return api.fetch(`/tasks/${id}`, {
                method: 'DELETE'
            });
        },

        async getStatistics() {
            return api.fetch('/tasks/statistics');
        }
    },

    // Tag endpoints
    tags: {
        async getAll() {
            return api.fetch('/tags');
        },

        async create(tagData) {
            return api.fetch('/tags', {
                method: 'POST',
                body: JSON.stringify(tagData)
            });
        },

        async update(id, tagData) {
            return api.fetch(`/tags/${id}`, {
                method: 'PUT',
                body: JSON.stringify(tagData)
            });
        },

        async delete(id) {
            return api.fetch(`/tags/${id}`, {
                method: 'DELETE'
            });
        },

        async addToTask(taskId, tagId) {
            return api.fetch(`/tasks/${taskId}/tags`, {
                method: 'POST',
                body: JSON.stringify({ tag_id: tagId })
            });
        },

        async removeFromTask(taskId, tagId) {
            return api.fetch(`/tasks/${taskId}/tags/${tagId}`, {
                method: 'DELETE'
            });
        }
    },

    // Comment endpoints
    comments: {
        async getForTask(taskId) {
            return api.fetch(`/tasks/${taskId}/comments`);
        },

        async create(taskId, content) {
            return api.fetch(`/tasks/${taskId}/comments`, {
                method: 'POST',
                body: JSON.stringify({ content })
            });
        },

        async update(commentId, content) {
            return api.fetch(`/comments/${commentId}`, {
                method: 'PUT',
                body: JSON.stringify({ content })
            });
        },

        async delete(commentId) {
            return api.fetch(`/comments/${commentId}`, {
                method: 'DELETE'
            });
        }
    }
};

// Check if user is already logged in
document.addEventListener('DOMContentLoaded', () => {
    // Redirect to login if not authenticated and not on login/register page
    const isAuthPage = window.location.pathname.includes('login.html') || 
                      window.location.pathname.includes('register.html');
    
    if (!api.isAuthenticated() && !isAuthPage) {
        window.location.href = 'login.html';
    } else if (api.isAuthenticated() && isAuthPage) {
        window.location.href = 'index.html';
    }
});

### File: C:\Users\rdjon\task-management-api\task-manager-frontend\js\auth.js
document.addEventListener('DOMContentLoaded', () => {
    // Session management
    let sessionWarningShown = false;

    function checkSessionExpiry() {
        const token = api.getToken();
        if (!token) return;
        
        try {
            // Decode JWT to check expiry (basic decode, not verification)
            const payload = JSON.parse(atob(token.split('.')[1]));
            const expiryTime = payload.exp * 1000;
            const now = Date.now();
            const timeUntilExpiry = expiryTime - now;
            
            // Warn 5 minutes before expiry
            if (timeUntilExpiry < 5 * 60 * 1000 && timeUntilExpiry > 0 && !sessionWarningShown) {
                sessionWarningShown = true;
                feedback.showError(
                    { message: 'Your session will expire soon. Please save your work.' },
                    ''
                );
            }
        } catch (e) {
            // Invalid token format, ignore
        }
    }

    // Check session every minute
    if (typeof feedback !== 'undefined') {
        setInterval(checkSessionExpiry, 60000);
    }

    // Handle login form
    const loginForm = document.getElementById('login-form');
    if (loginForm) {
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const errorMessage = document.getElementById('error-message');
            
            try {
                errorMessage.style.display = 'none';
                const submitBtn = loginForm.querySelector('button[type="submit"]');
                const originalText = submitBtn.textContent;
                submitBtn.textContent = 'Logging in...';
                submitBtn.disabled = true;
                
                const data = await api.auth.login(email, password);
                
                // Save tokens and user data
                api.setToken(data.access_token);
                api.setRefreshToken(data.refresh_token);
                api.setUser(data.user);
                
                // Show success message if feedback is available
                if (typeof feedback !== 'undefined') {
                    feedback.showSuccess('Login successful! Redirecting...');
                }
                
                // Redirect to main page
                setTimeout(() => {
                    window.location.href = 'index.html';
                }, 500);
            } catch (error) {
                errorMessage.textContent = error.message.includes('Invalid credentials') 
                    ? 'Incorrect email or password. Please try again.'
                    : error.message;
                errorMessage.style.display = 'block';
                
                // Re-enable button
                const submitBtn = loginForm.querySelector('button[type="submit"]');
                submitBtn.textContent = 'Login';
                submitBtn.disabled = false;
            }
        });
    }
    
    // Handle register form
    const registerForm = document.getElementById('register-form');
    if (registerForm) {
        registerForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const username = document.getElementById('username').value;
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const errorMessage = document.getElementById('error-message');
            
            try {
                errorMessage.style.display = 'none';
                const submitBtn = registerForm.querySelector('button[type="submit"]');
                const originalText = submitBtn.textContent;
                submitBtn.textContent = 'Creating account...';
                submitBtn.disabled = true;
                
                // Client-side validation
                if (username.length < 3) {
                    throw new Error('Username must be at least 3 characters long');
                }
                if (password.length < 8) {
                    throw new Error('Password must be at least 8 characters long');
                }
                if (!email.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
                    throw new Error('Please enter a valid email address');
                }
                
                const data = await api.auth.register(username, email, password);
                
                // Save tokens and user data
                api.setToken(data.access_token);
                api.setRefreshToken(data.refresh_token);
                api.setUser(data.user);
                
                // Show success message if feedback is available
                if (typeof feedback !== 'undefined') {
                    feedback.showSuccess('Account created successfully! Redirecting...');
                }
                
                // Redirect to main page
                setTimeout(() => {
                    window.location.href = 'index.html';
                }, 500);
            } catch (error) {
                errorMessage.textContent = error.message;
                errorMessage.style.display = 'block';
                
                // Re-enable button
                const submitBtn = registerForm.querySelector('button[type="submit"]');
                submitBtn.textContent = 'Register';
                submitBtn.disabled = false;
            }
        });
    }
    
    // Handle logout button
    const logoutBtn = document.getElementById('logout-btn');
    if (logoutBtn) {
        logoutBtn.addEventListener('click', async () => {
            if (typeof feedback !== 'undefined') {
                feedback.confirm(
                    'Are you sure you want to log out?',
                    async () => {
                        try {
                            const stopLoading = feedback.showLoading(logoutBtn, 'Logging out...');
                            await api.auth.logout();
                            feedback.showSuccess('Logged out successfully');
                            setTimeout(() => {
                                window.location.href = 'login.html';
                            }, 500);
                        } catch (error) {
                            console.error('Logout error:', error);
                            // Still redirect even if there's an error
                            window.location.href = 'login.html';
                        }
                    }
                );
            } else {
                // Fallback without feedback module
                if (confirm('Are you sure you want to log out?')) {
                    try {
                        await api.auth.logout();
                        window.location.href = 'login.html';
                    } catch (error) {
                        console.error('Logout error:', error);
                        window.location.href = 'login.html';
                    }
                }
            }
        });
    }
    
    // Display username in the header
    const usernameElement = document.getElementById('username');
    if (usernameElement) {
        const user = api.getUser();
        if (user) {
            usernameElement.textContent = user.username;
        }
    }
});

### File: C:\Users\rdjon\task-management-api\task-manager-frontend\js\comments.js
document.addEventListener('DOMContentLoaded', () => {
    // DOM elements
    const commentModal = document.getElementById('comment-modal');
    const commentTaskTitle = document.getElementById('comment-task-title');
    const commentTaskDescription = document.getElementById('comment-task-description');
    const commentsContainer = document.getElementById('comments-container');
    const commentForm = document.getElementById('comment-form');
    const commentTaskId = document.getElementById('comment-task-id');
    const commentContent = document.getElementById('comment-content');
    
    // Open comment modal
    async function openCommentModal(taskId) {
        try {
            // Get task details
            const task = await api.tasks.getById(taskId);
            
            // Set task details in modal
            commentTaskTitle.textContent = task.title;
            commentTaskDescription.textContent = task.description || 'No description';
            commentTaskId.value = task.id;
            
            // Load comments
            await loadComments(task.id);
            
            // Show modal
            commentModal.style.display = 'block';
        } catch (error) {
            console.error('Error opening comment modal:', error);
            alert(`Error loading task comments: ${error.message}`);
        }
    }
    
    // Load comments for a task
    async function loadComments(taskId) {
        try {
            commentsContainer.innerHTML = '<div class="loading">Loading comments...</div>';
            
            const comments = await api.comments.getForTask(taskId);
            
            if (comments.length === 0) {
                commentsContainer.innerHTML = '<p>No comments yet. Be the first to comment!</p>';
                return;
            }
            
            commentsContainer.innerHTML = '';
            comments.forEach(comment => {
                commentsContainer.appendChild(createCommentElement(comment));
            });
        } catch (error) {
            console.error('Error loading comments:', error);
            commentsContainer.innerHTML = `<p>Error loading comments: ${error.message}</p>`;
        }
    }
    
    // Create comment element
    function createCommentElement(comment) {
        const commentEl = document.createElement('div');
        commentEl.className = 'comment';
        commentEl.dataset.id = comment.id;
        
        // Format date
        const createdAt = new Date(comment.created_at).toLocaleString();
        
        commentEl.innerHTML = `
            <div class="comment-header">
                <span>${createdAt}</span>
                <div class="comment-actions">
                    <button class="btn btn-small edit-comment-btn" data-id="${comment.id}">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button class="btn btn-small btn-danger delete-comment-btn" data-id="${comment.id}">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
            <div class="comment-body">${comment.content}</div>
        `;
        
        return commentEl;
    }
    
    // Add comment
    async function addComment(taskId, content) {
        try {
            await api.comments.create(taskId, content);
            commentContent.value = '';
            await loadComments(taskId);
        } catch (error) {
            console.error('Error adding comment:', error);
            alert(`Error adding comment: ${error.message}`);
        }
    }
    
    // Edit comment
    async function editComment(commentId, content) {
        try {
            await api.comments.update(commentId, content);
            await loadComments(commentTaskId.value);
        } catch (error) {
            console.error('Error updating comment:', error);
            alert(`Error updating comment: ${error.message}`);
        }
    }
    
    // Delete comment
    async function deleteComment(commentId) {
        if (confirm('Are you sure you want to delete this comment?')) {
            try {
                await api.comments.delete(commentId);
                await loadComments(commentTaskId.value);
            } catch (error) {
                console.error('Error deleting comment:', error);
                alert(`Error deleting comment: ${error.message}`);
            }
        }
    }
    
    // Setup event listeners
    function setupEventListeners() {
        // Close modal buttons
        document.querySelectorAll('#comment-modal .close').forEach(btn => {
            btn.addEventListener('click', () => {
                commentModal.style.display = 'none';
            });
        });
        
        // Comment form submission
        if (commentForm) {
            commentForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const taskId = commentTaskId.value;
                const content = commentContent.value.trim();
                
                if (!content) {
                    alert('Please enter a comment');
                    return;
                }
                
                await addComment(taskId, content);
            });
        }
        
        // Comment actions (using event delegation)
        if (commentsContainer) {
            commentsContainer.addEventListener('click', async (e) => {
                // Edit comment button
                if (e.target.closest('.edit-comment-btn')) {
                    const commentId = e.target.closest('.edit-comment-btn').dataset.id;
                    const commentEl = e.target.closest('.comment');
                    const commentBody = commentEl.querySelector('.comment-body');
                    const currentContent = commentBody.textContent;
                    
                    const newContent = prompt('Edit your comment:', currentContent);
                    if (newContent && newContent.trim() !== currentContent) {
                        await editComment(commentId, newContent.trim());
                    }
                }
                
                // Delete comment button
                if (e.target.closest('.delete-comment-btn')) {
                    const commentId = e.target.closest('.delete-comment-btn').dataset.id;
                    await deleteComment(commentId);
                }
            });
        }
    }
    
    // Initialise
    function init() {
        setupEventListeners();
    }
    
    // Initialise the comments module
    init();
    
    // Export functions for use in other modules
    window.commentModule = {
        openCommentModal
    };
    
    // Make the openCommentModal function globally available
    window.openCommentModal = openCommentModal;
});

### File: C:\Users\rdjon\task-management-api\task-manager-frontend\js\feedback.js
// js/feedback.js
const feedback = {
    // Show success message
    showSuccess(message, duration = 3000) {
        const existingToast = document.querySelector('.toast');
        if (existingToast) existingToast.remove();
        
        const toast = document.createElement('div');
        toast.className = 'toast toast-success';
        toast.innerHTML = `
            <i class="fas fa-check-circle"></i>
            <span>${message}</span>
        `;
        document.body.appendChild(toast);
        
        setTimeout(() => toast.classList.add('show'), 10);
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, duration);
    },
    
    // Show error message with user-friendly text
    showError(error, context = '') {
        const existingToast = document.querySelector('.toast');
        if (existingToast) existingToast.remove();
        
        // Map technical errors to user-friendly messages
        let userMessage = this.getUserFriendlyError(error, context);
        
        const toast = document.createElement('div');
        toast.className = 'toast toast-error';
        toast.innerHTML = `
            <i class="fas fa-exclamation-circle"></i>
            <span>${userMessage}</span>
        `;
        document.body.appendChild(toast);
        
        setTimeout(() => toast.classList.add('show'), 10);
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, 5000);
    },
    
    // Convert technical errors to user-friendly messages
    getUserFriendlyError(error, context) {
        const errorMessage = error.message || error;
        
        // Network errors
        if (errorMessage.includes('NetworkError') || errorMessage.includes('Failed to fetch')) {
            return 'Unable to connect to the server. Please check your internet connection and try again.';
        }
        
        // Authentication errors
        if (errorMessage.includes('Token has expired')) {
            return 'Your session has expired. Please log in again.';
        }
        if (errorMessage.includes('Authorization required')) {
            return 'Please log in to access this feature.';
        }
        if (errorMessage.includes('Invalid credentials')) {
            return 'Incorrect email or password. Please try again.';
        }
        
        // Permission errors
        if (errorMessage.includes('Admin privileges required')) {
            return 'You need administrator privileges to perform this action.';
        }
        if (errorMessage.includes('permission')) {
            return 'You don\'t have permission to perform this action.';
        }
        
        // Validation errors
        if (errorMessage.includes('already exists')) {
            if (context === 'tag') return 'A tag with this name already exists. Please choose a different name.';
            if (context === 'user') return 'This email or username is already registered.';
            return 'This item already exists. Please choose a different name.';
        }
        
        // Rate limiting
        if (errorMessage.includes('Rate limit exceeded')) {
            return 'You\'re making too many requests. Please wait a moment and try again.';
        }
        
        // Not found errors
        if (errorMessage.includes('not found')) {
            if (context === 'task') return 'This task no longer exists. It may have been deleted.';
            if (context === 'tag') return 'This tag no longer exists.';
            if (context === 'comment') return 'This comment no longer exists.';
            return 'The requested item could not be found.';
        }
        
        // Generic fallback
        return `Something went wrong${context ? ` while ${context}` : ''}. Please try again.`;
    },
    
    // Show loading state
    showLoading(element, text = 'Loading...') {
        const original = element.innerHTML;
        element.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${text}`;
        element.disabled = true;
        return () => {
            element.innerHTML = original;
            element.disabled = false;
        };
    },
    
    // Show inline validation error
    showFieldError(fieldId, message) {
        const field = document.getElementById(fieldId);
        if (!field) return;
        
        // Remove any existing error
        const existingError = field.parentElement.querySelector('.field-error');
        if (existingError) existingError.remove();
        
        // Add error message
        const errorDiv = document.createElement('div');
        errorDiv.className = 'field-error';
        errorDiv.textContent = message;
        field.parentElement.appendChild(errorDiv);
        field.classList.add('error');
    },
    
    // Clear field error
    clearFieldError(fieldId) {
        const field = document.getElementById(fieldId);
        if (!field) return;
        
        const existingError = field.parentElement.querySelector('.field-error');
        if (existingError) existingError.remove();
        field.classList.remove('error');
    },
    
    // Show confirmation dialog
    confirm(message, onConfirm, onCancel = () => {}) {
        const modal = document.createElement('div');
        modal.className = 'confirmation-modal';
        modal.innerHTML = `
            <div class="confirmation-content">
                <h3>Confirm Action</h3>
                <p>${message}</p>
                <div class="confirmation-buttons">
                    <button class="btn btn-outline" id="cancel-btn">Cancel</button>
                    <button class="btn btn-danger" id="confirm-btn">Confirm</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        setTimeout(() => modal.classList.add('show'), 10);
        
        const cleanup = () => {
            modal.classList.remove('show');
            setTimeout(() => modal.remove(), 300);
        };
        
        document.getElementById('cancel-btn').onclick = () => {
            cleanup();
            onCancel();
        };
        
        document.getElementById('confirm-btn').onclick = () => {
            cleanup();
            onConfirm();
        };
    }
};

### File: C:\Users\rdjon\task-management-api\task-manager-frontend\js\tags.js
document.addEventListener('DOMContentLoaded', () => {
    // DOM elements
    const tagsList = document.getElementById('tags-list');
    const newTagName = document.getElementById('new-tag-name');
    const newTagColor = document.getElementById('new-tag-color');
    const addTagBtn = document.getElementById('add-tag-btn');
    const tagFilter = document.getElementById('tag-filter');
    
    // Load tags
    async function loadTags() {
        try {
            const tags = await api.tags.getAll();
            
            // Update tags list
            if (tagsList) {
                tagsList.innerHTML = '';
                
                if (tags.length === 0) {
                    tagsList.innerHTML = '<p>No tags created yet.</p>';
                    return;
                }
                
                tags.forEach(tag => {
                    const tagElement = document.createElement('span');
                    tagElement.className = 'tag';
                    tagElement.dataset.id = tag.id;
                    tagElement.style.backgroundColor = tag.color;
                    tagElement.style.color = 'white';
                    tagElement.innerHTML = `
                        ${tag.name}
                        <i class="fas fa-times delete-tag" data-id="${tag.id}"></i>
                    `;
                    tagsList.appendChild(tagElement);
                });
            }
            
            // Update tag filter
            if (tagFilter) {
                // Save current selection
                const currentValue = tagFilter.value;
                
                // Clear options except first "All" option
                while (tagFilter.options.length > 1) {
                    tagFilter.options.remove(1);
                }
                
                // Add tag options
                tags.forEach(tag => {
                    const option = document.createElement('option');
                    option.value = tag.id;
                    option.textContent = tag.name;
                    tagFilter.appendChild(option);
                });
                
                // Restore selection if possible
                if (currentValue) {
                    tagFilter.value = currentValue;
                }
            }
        } catch (error) {
            console.error('Error loading tags:', error);
            if (tagsList) {
                tagsList.innerHTML = '<p>Error loading tags. Please try again.</p>';
            }
        }
    }
    
    // Create a new tag
    async function createTag() {
        const name = newTagName.value.trim();
        const color = newTagColor.value;
        
        if (!name) {
            alert('Please enter a tag name');
            return;
        }
        
        try {
            await api.tags.create({ name, color });
            newTagName.value = '';
            loadTags();
        } catch (error) {
            console.error('Error creating tag:', error);
            alert(`Error creating tag: ${error.message}`);
        }
    }
    
    // Delete a tag
    async function deleteTag(tagId) {
        if (confirm('Are you sure you want to delete this tag?')) {
            try {
                await api.tags.delete(tagId);
                loadTags();
            } catch (error) {
                console.error('Error deleting tag:', error);
                alert(`Error deleting tag: ${error.message}`);
            }
        }
    }
    
    // Setup event listeners
    function setupEventListeners() {
        // Add tag button
        if (addTagBtn) {
            addTagBtn.addEventListener('click', createTag);
        }
        
        // New tag input - submit on Enter
        if (newTagName) {
            newTagName.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    createTag();
                }
            });
        }
        
        // Delete tag buttons (using event delegation)
        if (tagsList) {
            tagsList.addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-tag')) {
                    const tagId = e.target.dataset.id;
                    deleteTag(tagId);
                }
            });
        }
    }
    
    // Initialise
    function init() {
        loadTags();
        setupEventListeners();
    }
    
    // Initialise the tags module
    init();
    
    // Export functions for use in other modules
    window.tagsModule = {
        loadTags
    };
});

### File: C:\Users\rdjon\task-management-api\task-manager-frontend\js\tasks.js
document.addEventListener('DOMContentLoaded', () => {
    // DOM elements
    const tasksContainer = document.getElementById('tasks-container');
    const newTaskBtn = document.getElementById('new-task-btn');
    const taskModal = document.getElementById('task-modal');
    const modalTitle = document.getElementById('modal-title');
    const taskForm = document.getElementById('task-form');
    const taskIdInput = document.getElementById('task-id');
    const taskTitleInput = document.getElementById('task-title');
    const taskDescriptionInput = document.getElementById('task-description');
    const taskStatusSelect = document.getElementById('task-status');
    const taskPrioritySelect = document.getElementById('task-priority');
    const taskDueDateInput = document.getElementById('task-due-date');
    const taskTagsContainer = document.getElementById('task-tags');
    const cancelTaskBtn = document.getElementById('cancel-task-btn');
    const statusFilter = document.getElementById('status-filter');
    const priorityFilter = document.getElementById('priority-filter');
    const tagFilter = document.getElementById('tag-filter');
    const searchInput = document.getElementById('search-input');
    const applyFiltersBtn = document.getElementById('apply-filters-btn');
    const prevPageBtn = document.getElementById('prev-page-btn');
    const nextPageBtn = document.getElementById('next-page-btn');
    const paginationInfo = document.getElementById('pagination-info');
    
    // State
    let currentPage = 1;
    let totalPages = 1;
    let filters = {
        status: '',
        priority: '',
        tag: '',
        search: '',
        page: 1,
        per_page: 10
    };
    
    // Initialise
    function init() {
        loadTasks();
        loadStatistics();
        setupEventListeners();
    }
    
    // Load tasks
    async function loadTasks() {
        try {
            tasksContainer.innerHTML = '<div class="loading"><i class="fas fa-spinner fa-spin"></i> Loading tasks...</div>';
            
            const data = await api.tasks.getAll({
                ...filters,
                page: currentPage
            });
            
            // Update pagination
            totalPages = data.pages;
            updatePagination();
            
            if (data.tasks.length === 0) {
                renderEmptyState();
                return;
            }
            
            tasksContainer.innerHTML = '';
            data.tasks.forEach(task => {
                tasksContainer.appendChild(createTaskCard(task));
            });
        } catch (error) {
            console.error('Error loading tasks:', error);
            tasksContainer.innerHTML = `<div class="empty-state">
                <i class="fas fa-exclamation-triangle"></i>
                <h3>Unable to load tasks</h3>
                <p>${feedback.getUserFriendlyError(error, 'loading tasks')}</p>
                <button class="btn btn-primary" onclick="location.reload()">Try Again</button>
            </div>`;
        }
    }
    
    // Render empty state
    function renderEmptyState() {
        tasksContainer.innerHTML = `
            <div class="empty-state">
                <i class="fas fa-tasks"></i>
                <h3>No tasks found</h3>
                <p>${filters.search ? 'Try adjusting your search criteria' : 'Create your first task to get started'}</p>
                ${!filters.search ? '<button class="btn btn-primary" onclick="document.getElementById(\'new-task-btn\').click()">Create Task</button>' : ''}
            </div>
        `;
    }
    
    // Load task statistics
    async function loadStatistics() {
        try {
            const statistics = await api.tasks.getStatistics();
            const statisticsContent = document.getElementById('statistics-content');
            
            if (statisticsContent) {
                let html = `
                    <div class="statistics-item">
                        <span>Total Tasks:</span>
                        <span>${statistics.total_tasks}</span>
                    </div>
                `;
                
                // Status statistics
                html += '<div class="statistics-item"><span>By Status:</span></div>';
                for (const [status, count] of Object.entries(statistics.by_status)) {
                    html += `
                        <div class="statistics-item">
                            <span style="padding-left: 1rem">${status.charAt(0).toUpperCase() + status.slice(1).replace('_', ' ')}:</span>
                            <span>${count}</span>
                        </div>
                    `;
                }
                
                // Priority statistics
                html += '<div class="statistics-item"><span>By Priority:</span></div>';
                for (const [priority, count] of Object.entries(statistics.by_priority)) {
                    html += `
                        <div class="statistics-item">
                            <span style="padding-left: 1rem">${priority.charAt(0).toUpperCase() + priority.slice(1)}:</span>
                            <span>${count}</span>
                        </div>
                    `;
                }
                
                // Overdue and upcoming tasks
                if (statistics.overdue_tasks > 0) {
                    html += `
                        <div class="statistics-item" style="color: var(--danger-color)">
                            <span>Overdue:</span>
                            <span>${statistics.overdue_tasks}</span>
                        </div>
                    `;
                }
                
                if (statistics.upcoming_tasks > 0) {
                    html += `
                        <div class="statistics-item" style="color: var(--warning-color)">
                            <span>Due Soon:</span>
                            <span>${statistics.upcoming_tasks}</span>
                        </div>
                    `;
                }
                
                statisticsContent.innerHTML = html;
            }
        } catch (error) {
            console.error('Error loading statistics:', error);
            const statisticsContent = document.getElementById('statistics-content');
            if (statisticsContent) {
                statisticsContent.innerHTML = '<p style="color: #999; text-align: center;">Unable to load statistics</p>';
            }
        }
    }
    
    // Create task card
    function createTaskCard(task) {
        const card = document.createElement('div');
        card.className = 'task-card';
        card.dataset.id = task.id;
        
        // Format the date
        const dueDateFormatted = task.due_date ? new Date(task.due_date).toLocaleString() : 'No due date';
        
        // Check if overdue
        const isOverdue = task.due_date && new Date(task.due_date) < new Date() && task.status !== 'completed';
        
        // Create the tags HTML
        let tagsHTML = '';
        if (task.tags && task.tags.length > 0) {
            tagsHTML = '<div class="task-tags">';
            task.tags.forEach(tag => {
                tagsHTML += `<span class="tag" style="background-color: ${tag.color}; color: white;">${tag.name}</span>`;
            });
            tagsHTML += '</div>';
        }
        
        card.innerHTML = `
            <div class="task-header">
                <h3 class="task-title">${task.title}</h3>
                <span class="task-status ${task.status}">${task.status.replace('_', ' ')}</span>
            </div>
            <div class="task-body">
                <p class="task-description">${task.description || 'No description'}</p>
                <div class="task-meta">
                    <div>
                        <span class="task-priority ${task.priority}">
                            <i class="fas fa-flag"></i> ${task.priority}
                        </span>
                        <span class="task-due-date ${isOverdue ? 'overdue' : ''}">
                            <i class="far fa-calendar-alt"></i> ${dueDateFormatted}
                            ${isOverdue ? '<i class="fas fa-exclamation-triangle" style="color: var(--danger-color);"></i>' : ''}
                        </span>
                    </div>
                </div>
                ${tagsHTML}
            </div>
            <div class="task-footer">
                <div class="task-actions">
                    <button class="btn btn-small edit-task-btn" data-id="${task.id}">
                        <i class="fas fa-edit"></i> Edit
                    </button>
                    <button class="btn btn-small btn-danger delete-task-btn" data-id="${task.id}">
                        <i class="fas fa-trash"></i> Delete
                    </button>
                </div>
                <div class="task-comments" data-id="${task.id}">
                    <i class="far fa-comment"></i> Comments
                </div>
            </div>
        `;
        
        return card;
    }
    
    // Validate task form
    function validateTaskForm() {
        let isValid = true;
        
        // Clear previous errors
        feedback.clearFieldError('task-title');
        feedback.clearFieldError('task-due-date');
        
        // Validate title
        const title = taskTitleInput.value.trim();
        if (!title) {
            feedback.showFieldError('task-title', 'Please enter a task title');
            isValid = false;
        } else if (title.length > 100) {
            feedback.showFieldError('task-title', 'Title must be less than 100 characters');
            isValid = false;
        }
        
        // Validate due date
        const dueDate = taskDueDateInput.value;
        if (dueDate) {
            const selectedDate = new Date(dueDate);
            const now = new Date();
            if (selectedDate < now && !taskIdInput.value) { // Only validate for new tasks
                feedback.showFieldError('task-due-date', 'Due date cannot be in the past');
                isValid = false;
            }
        }
        
        return isValid;
    }
    
    // Setup task modal for creating/editing
    function setupTaskModal(mode, taskId = null) {
        // Clear previous form data
        taskForm.reset();
        taskIdInput.value = '';
        
        // Clear any validation errors
        feedback.clearFieldError('task-title');
        feedback.clearFieldError('task-due-date');
        
        // Update modal title based on mode
        modalTitle.textContent = mode === 'create' ? 'New Task' : 'Edit Task';
        
        // Load task data if editing
        if (mode === 'edit' && taskId) {
            loadTaskForEditing(taskId);
        }
        
        // Load tags for selection
        loadTagsForTaskForm();
        
        // Show modal
        taskModal.style.display = 'block';
    }
    
    // Load task data for editing
    async function loadTaskForEditing(taskId) {
        try {
            const task = await api.tasks.getById(taskId);
            
            // Populate form fields
            taskIdInput.value = task.id;
            taskTitleInput.value = task.title;
            taskDescriptionInput.value = task.description || '';
            taskStatusSelect.value = task.status;
            taskPrioritySelect.value = task.priority;
            
            // Format due date for datetime-local input
            if (task.due_date) {
                const dueDate = new Date(task.due_date);
                const localDatetime = new Date(dueDate.getTime() - dueDate.getTimezoneOffset() * 60000)
                    .toISOString()
                    .slice(0, 16);
                taskDueDateInput.value = localDatetime;
            } else {
                taskDueDateInput.value = '';
            }
            
            // Store task tags for selection after tags are loaded
            window.taskTagIds = task.tags ? task.tags.map(tag => tag.id) : [];
        } catch (error) {
            console.error('Error loading task for editing:', error);
            closeTaskModal();
            feedback.showError(error, 'loading task');
        }
    }
    
    // Load tags for task form
    async function loadTagsForTaskForm() {
        try {
            const tags = await api.tags.getAll();
            
            if (taskTagsContainer) {
                taskTagsContainer.innerHTML = '';
                
                if (tags.length === 0) {
                    taskTagsContainer.innerHTML = '<p class="help-text">No tags available. Create tags in the sidebar.</p>';
                    return;
                }
                
                tags.forEach(tag => {
                    const tagItem = document.createElement('div');
                    tagItem.className = 'task-tag-item';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `tag-${tag.id}`;
                    checkbox.value = tag.id;
                    checkbox.name = 'tag_ids[]';
                    
                    // Check the checkbox if tag is selected for the task
                    if (window.taskTagIds && window.taskTagIds.includes(tag.id)) {
                        checkbox.checked = true;
                    }
                    
                    const label = document.createElement('label');
                    label.htmlFor = `tag-${tag.id}`;
                    label.innerHTML = `<span class="tag" style="background-color: ${tag.color}; color: white;">${tag.name}</span>`;
                    
                    tagItem.appendChild(checkbox);
                    tagItem.appendChild(label);
                    taskTagsContainer.appendChild(tagItem);
                });
            }
        } catch (error) {
            console.error('Error loading tags for task form:', error);
            taskTagsContainer.innerHTML = '<p class="help-text" style="color: var(--danger-color);">Error loading tags. Please try again.</p>';
        }
    }
    
    // Close task modal
    function closeTaskModal() {
        taskModal.style.display = 'none';
        taskForm.reset();
        delete window.taskTagIds;
        // Clear any validation errors
        feedback.clearFieldError('task-title');
        feedback.clearFieldError('task-due-date');
    }
    
    // Update pagination buttons and info
    function updatePagination() {
        prevPageBtn.disabled = currentPage <= 1;
        nextPageBtn.disabled = currentPage >= totalPages;
        paginationInfo.textContent = `Page ${currentPage} of ${totalPages}`;
    }
    
    // Setup event listeners
    function setupEventListeners() {
        // New task button
        if (newTaskBtn) {
            newTaskBtn.addEventListener('click', () => setupTaskModal('create'));
        }
        
        // Close modal buttons
        document.querySelectorAll('.close, #cancel-task-btn').forEach(btn => {
            btn.addEventListener('click', closeTaskModal);
        });
        
        // Task form submission
        if (taskForm) {
            taskForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                // Validate form
                if (!validateTaskForm()) {
                    return;
                }
                
                // Show loading state
                const stopLoading = feedback.showLoading(
                    document.getElementById('save-task-btn'),
                    taskIdInput.value ? 'Updating...' : 'Creating...'
                );
                
                try {
                    // Get form data
                    const formData = {
                        title: taskTitleInput.value,
                        description: taskDescriptionInput.value,
                        status: taskStatusSelect.value,
                        priority: taskPrioritySelect.value,
                        due_date: taskDueDateInput.value || null
                    };
                    
                    // Get selected tags
                    const tagCheckboxes = taskForm.querySelectorAll('input[name="tag_ids[]"]:checked');
                    if (tagCheckboxes.length > 0) {
                        formData.tag_ids = Array.from(tagCheckboxes).map(cb => parseInt(cb.value));
                    }
                    
                    // Create or update task
                    const taskId = taskIdInput.value;
                    if (taskId) {
                        await api.tasks.update(taskId, formData);
                        feedback.showSuccess('Task updated successfully!');
                    } else {
                        await api.tasks.create(formData);
                        feedback.showSuccess('Task created successfully!');
                    }
                    
                    // Close modal and reload tasks
                    closeTaskModal();
                    loadTasks();
                    loadStatistics();
                } catch (error) {
                    console.error('Error saving task:', error);
                    feedback.showError(error, 'saving the task');
                } finally {
                    stopLoading();
                }
            });
        }
        
        // Task card buttons (using event delegation)
        if (tasksContainer) {
            tasksContainer.addEventListener('click', async (e) => {
                // Edit button
                if (e.target.closest('.edit-task-btn')) {
                    const taskId = e.target.closest('.edit-task-btn').dataset.id;
                    setupTaskModal('edit', taskId);
                }
                
                // Delete button
                if (e.target.closest('.delete-task-btn')) {
                    const taskId = e.target.closest('.delete-task-btn').dataset.id;
                    const taskCard = e.target.closest('.task-card');
                    const taskTitle = taskCard.querySelector('.task-title').textContent;
                    
                    feedback.confirm(
                        `Are you sure you want to delete "${taskTitle}"? This action cannot be undone.`,
                        async () => {
                            const deleteBtn = e.target.closest('.delete-task-btn');
                            const originalContent = deleteBtn.innerHTML;
                            deleteBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                            deleteBtn.disabled = true;
                            
                            try {
                                await api.tasks.delete(taskId);
                                feedback.showSuccess('Task deleted successfully');
                                loadTasks();
                                loadStatistics();
                            } catch (error) {
                                console.error('Error deleting task:', error);
                                feedback.showError(error, 'deleting the task');
                                // Re-enable button on error
                                deleteBtn.innerHTML = originalContent;
                                deleteBtn.disabled = false;
                            }
                        }
                    );
                }
                
                // Comments button
                if (e.target.closest('.task-comments')) {
                    const taskId = e.target.closest('.task-comments').dataset.id;
                    openCommentModal(taskId);
                }
            });
        }
        
        // Filter application
        if (applyFiltersBtn) {
            applyFiltersBtn.addEventListener('click', () => {
                filters.status = statusFilter.value;
                filters.priority = priorityFilter.value;
                filters.tag = tagFilter.value;
                filters.search = searchInput.value;
                currentPage = 1;
                loadTasks();
            });
        }
        
        // Search on enter key
        if (searchInput) {
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    applyFiltersBtn.click();
                }
            });
        }
        
        // Pagination buttons
        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    loadTasks();
                }
            });
        }
        
        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    loadTasks();
                }
            });
        }
        
        // Close modals when clicking outside
        window.addEventListener('click', (e) => {
            if (e.target === taskModal) {
                closeTaskModal();
            }
            
            const commentModal = document.getElementById('comment-modal');
            if (commentModal && e.target === commentModal) {
                commentModal.style.display = 'none';
            }
        });
    }
    
    // Initialise the tasks module
    init();
});

### File: C:\Users\rdjon\task-management-api\tests\conftest.py
import pytest
from datetime import datetime, timedelta
from app import create_app, db
from app.models.user import User
from app.models.task import Task
from app.models.tag import Tag
from app.models.comment import Comment
from flask_jwt_extended import create_access_token, create_refresh_token

@pytest.fixture
def app():
    """Create application for the tests."""
    app = create_app('app.config.TestingConfig')
    
    # Create tables
    with app.app_context():
        db.create_all()
    
    yield app
    
    # Clean up
    with app.app_context():
        db.session.remove()
        db.drop_all()

@pytest.fixture
def client(app):
    """Create test client."""
    return app.test_client()

@pytest.fixture
def regular_user(app):
    """Create regular test user."""
    with app.app_context():
        user = User(
            username="testuser",
            email="test@example.com",
            password="password123",
            role="user"
        )
        db.session.add(user)
        db.session.commit()
        
        # Store the user ID for later use
        user_id = user.id
        
        # Clear the session to simulate real usage
        db.session.close()
        
        # Return a fresh instance of the user for each test
        fresh_user = db.session.get(User, user_id)
        yield fresh_user
        
        # Clean up session after the test is done
        db.session.close()

@pytest.fixture
def admin_user(app):
    """Create admin test user."""
    with app.app_context():
        admin = User(
            username="admin",
            email="admin@example.com",
            password="adminpassword",
            role="admin"
        )
        db.session.add(admin)
        db.session.commit()
        
        # Store the user ID for later use
        admin_id = admin.id
        
        # Clear the session to simulate real usage
        db.session.close()
        
        # Return a fresh instance of the user for each test
        fresh_admin = db.session.get(User, admin_id)
        yield fresh_admin
        
        # Clean up session after the test is done
        db.session.close()

@pytest.fixture
def auth_tokens(app, regular_user):
    """Create authentication tokens for a regular user."""
    with app.app_context():
        # Get a fresh instance to ensure it's attached to the session
        user = db.session.merge(regular_user)
        
        access_token = create_access_token(identity=str(user.id))
        refresh_token = create_refresh_token(identity=str(user.id))
        return {
            "access_token": access_token,
            "refresh_token": refresh_token
        }

@pytest.fixture
def admin_auth_tokens(app, admin_user):
    """Create authentication tokens for an admin user."""
    with app.app_context():
        # Get a fresh instance to ensure it's attached to the session
        admin = db.session.merge(admin_user)
        
        access_token = create_access_token(identity=str(admin.id))
        refresh_token = create_refresh_token(identity=str(admin.id))
        return {
            "access_token": access_token,
            "refresh_token": refresh_token
        }

@pytest.fixture
def auth_headers(auth_tokens):
    """Create authentication headers for a regular user."""
    return {
        "Authorisation": f"Bearer {auth_tokens['access_token']}"
    }

@pytest.fixture
def admin_auth_headers(admin_auth_tokens):
    """Create authentication headers for an admin user."""
    return {
        "Authorisation": f"Bearer {admin_auth_tokens['access_token']}"
    }

@pytest.fixture
def test_tasks(app, regular_user):
    """Create test tasks for a regular user."""
    with app.app_context():
        # Get a fresh instance to ensure it's attached to the session
        user = db.session.merge(regular_user)
        
        tasks = [
            Task(
                title="Test Task 1",
                description="Description for Test Task 1",
                status="pending",
                priority="high",
                due_date=datetime.utcnow() + timedelta(days=1),
                user_id=user.id
            ),
            Task(
                title="Test Task 2",
                description="Description for Test Task 2",
                status="in_progress",
                priority="medium",
                user_id=user.id
            ),
            Task(
                title="Test Task 3",
                description="Description for Test Task 3",
                status="completed",
                priority="low",
                user_id=user.id
            )
        ]
        
        db.session.add_all(tasks)
        db.session.commit()
        
        # Store task IDs
        task_ids = [task.id for task in tasks]
        
        # Clear the session
        db.session.close()
        
        # Return fresh instances
        fresh_tasks = [db.session.get(Task, task_id) for task_id in task_ids]
        return fresh_tasks

@pytest.fixture
def test_tags(app, regular_user):
    """Create test tags for a regular user."""
    with app.app_context():
        # Get a fresh instance to ensure it's attached to the session
        user = db.session.merge(regular_user)
        
        tags = [
            Tag(
                name="Work",
                color="#ff5500",
                user_id=user.id
            ),
            Tag(
                name="Personal",
                color="#00ff55",
                user_id=user.id
            ),
            Tag(
                name="Urgent",
                color="#ff0000",
                user_id=user.id
            )
        ]
        
        db.session.add_all(tags)
        db.session.commit()
        
        # Store tag IDs
        tag_ids = [tag.id for tag in tags]
        
        # Clear the session
        db.session.close()
        
        # Return fresh instances
        fresh_tags = [db.session.get(Tag, tag_id) for tag_id in tag_ids]
        return fresh_tags

@pytest.fixture
def test_comments(app, regular_user, test_tasks):
    """Create test comments for a task."""
    with app.app_context():
        # Get fresh instances
        user = db.session.merge(regular_user)
        task = db.session.merge(test_tasks[0])
        
        comments = [
            Comment(
                content="This is a test comment 1",
                task_id=task.id,
                user_id=user.id
            ),
            Comment(
                content="This is a test comment 2",
                task_id=task.id,
                user_id=user.id
            )
        ]
        
        db.session.add_all(comments)
        db.session.commit()
        
        # Store comment IDs
        comment_ids = [comment.id for comment in comments]
        
        # Clear the session
        db.session.close()
        
        # Return fresh instances
        fresh_comments = [db.session.get(Comment, comment_id) for comment_id in comment_ids]
        return fresh_comments

@pytest.fixture
def json_content_headers():
    """Create JSON content headers."""
    return {
        "Content-Type": "application/json"
    }

### File: C:\Users\rdjon\task-management-api\tests\__init__.py


### File: C:\Users\rdjon\task-management-api\tests\integration\test_admin.py
import json
import pytest

def test_get_users(client, app, regular_user, admin_user, admin_auth_headers, auth_headers):
    """Test getting all users (admin only)."""
    # Ensure objects are attached to session and store IDs
    with app.app_context():
        from app import db
        regular = db.session.merge(regular_user)
        admin = db.session.merge(admin_user)
        regular_id = regular.id
        admin_id = admin.id
    
    # Test successful retrieval as admin
    response = client.get('/api/v1/admin/users', headers=admin_auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert 'users' in data
    assert len(data['users']) >= 2  # At least regular_user and admin_user
    
    user_ids = [user['id'] for user in data['users']]
    assert regular_id in user_ids
    assert admin_id in user_ids
    
    # Test with pagination
    response = client.get('/api/v1/admin/users?page=1&per_page=1', headers=admin_auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert len(data['users']) == 1
    assert data['page'] == 1
    assert data['per_page'] == 1
    
    # Test access denied for regular user
    response = client.get('/api/v1/admin/users', headers=auth_headers)
    
    assert response.status_code == 403
    assert json.loads(response.data)['error'] == 'Admin privileges required'
    
    # Test without authentication
    response = client.get('/api/v1/admin/users')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_get_user(client, app, regular_user, admin_user, admin_auth_headers, auth_headers):
    """Test getting a specific user (admin only)."""
    # Ensure objects are attached to session and store expected values
    with app.app_context():
        from app import db
        regular = db.session.merge(regular_user)
        
        regular_id = regular.id
        expected_username = regular.username
        expected_email = regular.email
        expected_role = regular.role
    
    # Test successful retrieval as admin
    response = client.get(f'/api/v1/admin/users/{regular_id}', headers=admin_auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['id'] == regular_id
    assert data['username'] == expected_username
    assert data['email'] == expected_email
    assert data['role'] == expected_role
    
    # Test non-existent user
    response = client.get('/api/v1/admin/users/9999', headers=admin_auth_headers)
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'User not found'
    
    # Test access denied for regular user
    response = client.get(f'/api/v1/admin/users/{regular_id}', headers=auth_headers)
    
    assert response.status_code == 403
    assert json.loads(response.data)['error'] == 'Admin privileges required'
    
    # Test without authentication
    response = client.get(f'/api/v1/admin/users/{regular_id}')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_update_user(client, app, regular_user, admin_user, admin_auth_headers, auth_headers, json_content_headers):
    """Test updating a user (admin only)."""
    # Ensure objects are attached to session and store IDs
    with app.app_context():
        from app import db
        regular = db.session.merge(regular_user)
        regular_id = regular.id
    
    combined_admin_headers = {**admin_auth_headers, **json_content_headers}
    combined_regular_headers = {**auth_headers, **json_content_headers}
    
    # Test successful update as admin
    update_data = {
        'username': 'updated_user',
        'email': 'updated@example.com',
        'role': 'admin'  # Change role to admin
    }
    
    response = client.put(
        f'/api/v1/admin/users/{regular_id}',
        data=json.dumps(update_data),
        headers=combined_admin_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['message'] == 'User updated successfully'
    assert data['user']['username'] == update_data['username']
    assert data['user']['email'] == update_data['email']
    assert data['user']['role'] == update_data['role']
    
    # Verify in database
    with app.app_context():
        from app.models.user import User
        user = User.query.get(regular_id)
        assert user.username == update_data['username']
        assert user.email == update_data['email']
        assert user.role == update_data['role']
    
    # Test partial update
    partial_update = {
        'username': 'partially_updated_user'
    }
    
    response = client.put(
        f'/api/v1/admin/users/{regular_id}',
        data=json.dumps(partial_update),
        headers=combined_admin_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['user']['username'] == partial_update['username']
    assert data['user']['email'] == update_data['email']  # Unchanged
    assert data['user']['role'] == update_data['role']  # Unchanged
    
    # Test non-existent user
    response = client.put(
        '/api/v1/admin/users/9999',
        data=json.dumps(update_data),
        headers=combined_admin_headers
    )
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'User not found'
    
    # Test access denied for regular user
    response = client.put(
        f'/api/v1/admin/users/{regular_id}',
        data=json.dumps(update_data),
        headers=combined_regular_headers
    )
    
    assert response.status_code == 403
    assert json.loads(response.data)['error'] == 'Admin privileges required'
    
    # Test without authentication
    response = client.put(
        f'/api/v1/admin/users/{regular_id}',
        data=json.dumps(update_data),
        headers=json_content_headers
    )
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_delete_user(client, app, regular_user, admin_user, admin_auth_headers, auth_headers):
    """Test deleting a user (admin only)."""
    # Ensure objects are attached to session and store IDs
    with app.app_context():
        from app import db
        admin = db.session.merge(admin_user)
        admin_id = admin.id
    
    # Create a user to delete
    response = client.post(
        '/api/v1/auth/register',
        data=json.dumps({
            'username': 'user_to_delete',
            'email': 'delete@example.com',
            'password': 'password123'
        }),
        headers={'Content-Type': 'application/json'}
    )
    
    register_data = json.loads(response.data)
    user_id = register_data['user']['id']
    
    # Test successful deletion as admin
    response = client.delete(f'/api/v1/admin/users/{user_id}', headers=admin_auth_headers)
    
    assert response.status_code == 200
    assert json.loads(response.data)['message'] == 'User deleted successfully'
    
    # Verify in database
    with app.app_context():
        from app.models.user import User
        user = User.query.get(user_id)
        assert user is None
    
    # Test non-existent user
    response = client.delete('/api/v1/admin/users/9999', headers=admin_auth_headers)
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'User not found'
    
    # Test access denied for regular user
    response = client.delete(f'/api/v1/admin/users/{admin_id}', headers=auth_headers)
    
    assert response.status_code == 403
    assert json.loads(response.data)['error'] == 'Admin privileges required'
    
    # Test without authentication
    response = client.delete(f'/api/v1/admin/users/{admin_id}')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_admin_stats(client, app, regular_user, admin_user, test_tasks, admin_auth_headers, auth_headers):
    """Test getting admin statistics (admin only)."""
    # Ensure objects are attached to session
    with app.app_context():
        from app import db
        # Just merge one object to ensure it's attached
        db.session.merge(regular_user)
        db.session.merge(test_tasks[0])
    
    # Test successful retrieval as admin
    response = client.get('/api/v1/admin/stats', headers=admin_auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert 'user_stats' in data
    assert 'task_stats' in data
    assert data['user_stats']['total'] >= 2  # At least regular_user and admin_user
    assert 'admins' in data['user_stats']
    assert 'regular_users' in data['user_stats']
    assert data['task_stats']['total'] >= 3  # At least the 3 test tasks
    assert 'by_status' in data['task_stats']
    
    # Test access denied for regular user
    response = client.get('/api/v1/admin/stats', headers=auth_headers)
    
    assert response.status_code == 403
    assert json.loads(response.data)['error'] == 'Admin privileges required'
    
    # Test without authentication
    response = client.get('/api/v1/admin/stats')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

### File: C:\Users\rdjon\task-management-api\tests\integration\test_auth.py
import json
import pytest
from datetime import datetime, timedelta
from app.models.token_blacklist import TokenBlacklist

def test_register(client, json_content_headers):
    """Test user registration."""
    # Test successful registration
    response = client.post(
        '/api/v1/auth/register',
        data=json.dumps({
            'username': 'newuser',
            'email': 'new@example.com',
            'password': 'password123'
        }),
        headers=json_content_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 201
    assert 'access_token' in data
    assert 'refresh_token' in data
    assert data['user']['username'] == 'newuser'
    assert data['user']['email'] == 'new@example.com'
    assert data['user']['role'] == 'user'  # Default role
    
    # Test duplicate username
    response = client.post(
        '/api/v1/auth/register',
        data=json.dumps({
            'username': 'newuser',
            'email': 'another@example.com',
            'password': 'password123'
        }),
        headers=json_content_headers
    )
    
    assert response.status_code == 409
    assert json.loads(response.data)['error'] == 'User with this username already exists'
    
    # Test duplicate email
    response = client.post(
        '/api/v1/auth/register',
        data=json.dumps({
            'username': 'anotheruser',
            'email': 'new@example.com',
            'password': 'password123'
        }),
        headers=json_content_headers
    )
    
    assert response.status_code == 409
    assert json.loads(response.data)['error'] == 'User with this email already exists'
    
    # Test validation errors
    response = client.post(
        '/api/v1/auth/register',
        data=json.dumps({
            'username': 'ab',  # Too short
            'email': 'invalid-email',  # Invalid email
            'password': '123'  # Too short
        }),
        headers=json_content_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 400
    assert 'error' in data
    assert 'messages' in data
    assert 'username' in data['messages']
    assert 'email' in data['messages']
    assert 'password' in data['messages']

def test_login(client, app, regular_user, json_content_headers):
    """Test user login."""
    # Ensure we have the user's expected properties
    with app.app_context():
        from app import db
        user = db.session.merge(regular_user)
        expected_username = user.username
        expected_email = user.email
    
    # Test successful login
    response = client.post(
        '/api/v1/auth/login',
        data=json.dumps({
            'email': 'test@example.com',
            'password': 'password123'
        }),
        headers=json_content_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert 'access_token' in data
    assert 'refresh_token' in data
    assert data['user']['username'] == expected_username
    assert data['user']['email'] == expected_email
    
    # Test invalid credentials
    response = client.post(
        '/api/v1/auth/login',
        data=json.dumps({
            'email': 'test@example.com',
            'password': 'wrongpassword'
        }),
        headers=json_content_headers
    )
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Invalid credentials'
    
    # Test non-existent user
    response = client.post(
        '/api/v1/auth/login',
        data=json.dumps({
            'email': 'nonexistent@example.com',
            'password': 'password123'
        }),
        headers=json_content_headers
    )
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Invalid credentials'

def test_refresh_token(client, auth_tokens, json_content_headers):
    """Test token refresh."""
    # Test successful token refresh
    refresh_headers = {
        **json_content_headers,
        'Authorization': f"Bearer {auth_tokens['refresh_token']}"
    }
    
    response = client.post('/api/v1/auth/refresh', headers=refresh_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert 'access_token' in data
    
    # Test with access token (should fail)
    invalid_headers = {
        **json_content_headers,
        'Authorization': f"Bearer {auth_tokens['access_token']}"
    }
    
    response = client.post('/api/v1/auth/refresh', headers=invalid_headers)
    
    # Updated expectation - Flask-JWT-Extended returns 401 for wrong token type, not 422
    assert response.status_code == 401
    assert json.loads(response.data)['error'] in ['Token has expired', 'Invalid token']

def test_logout(client, app, auth_headers, json_content_headers):
    """Test user logout."""
    combined_headers = {**auth_headers, **json_content_headers}
    
    # Test successful logout
    response = client.post('/api/v1/auth/logout', headers=combined_headers)
    
    assert response.status_code == 200
    assert json.loads(response.data)['message'] == 'Successfully logged out'
    
    # Check if token was blacklisted
    with app.app_context():
        from app.models.token_blacklist import TokenBlacklist
        blacklisted = TokenBlacklist.query.count()
        assert blacklisted == 1
    
    # Test accessing protected endpoint after logout
    response = client.get('/api/v1/auth/me', headers=combined_headers)
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Token has been revoked'

def test_logout_all(client, app, auth_headers, json_content_headers):
    """Test logout from all devices."""
    combined_headers = {**auth_headers, **json_content_headers}
    
    # Test successful logout from all devices
    response = client.post('/api/v1/auth/logout/all', headers=combined_headers)
    
    assert response.status_code == 200
    assert json.loads(response.data)['message'] == 'Successfully logged out from all devices'
    
    # Check if token was blacklisted
    with app.app_context():
        from app.models.token_blacklist import TokenBlacklist
        blacklisted = TokenBlacklist.query.count()
        assert blacklisted == 1
    
    # Test accessing protected endpoint after logout
    response = client.get('/api/v1/auth/me', headers=combined_headers)
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Token has been revoked'

def test_me(client, app, regular_user, auth_headers):
    """Test getting current user details."""
    # Ensure we have the user's expected properties
    with app.app_context():
        from app import db
        user = db.session.merge(regular_user)
        expected_username = user.username
        expected_email = user.email
        expected_role = user.role
    
    # Test successful retrieval
    response = client.get('/api/v1/auth/me', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['username'] == expected_username
    assert data['email'] == expected_email
    assert data['role'] == expected_role
    
    # Test without authentication
    response = client.get('/api/v1/auth/me')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_update_me(client, app, regular_user, auth_headers, json_content_headers):
    """Test updating current user details."""
    # Get the user ID in a safe way
    with app.app_context():
        from app import db
        user = db.session.merge(regular_user)
        user_id = user.id
    
    combined_headers = {**auth_headers, **json_content_headers}
    
    # Test updating username
    response = client.put(
        '/api/v1/auth/me',
        data=json.dumps({
            'username': 'updateduser'
        }),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['message'] == 'User updated successfully'
    assert data['user']['username'] == 'updateduser'
    
    # Verify in database
    with app.app_context():
        from app.models.user import User
        user = User.query.get(user_id)
        assert user.username == 'updateduser'
    
    # Test updating email
    response = client.put(
        '/api/v1/auth/me',
        data=json.dumps({
            'email': 'updated@example.com'
        }),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['message'] == 'User updated successfully'
    assert data['user']['email'] == 'updated@example.com'
    
    # Test updating password
    response = client.put(
        '/api/v1/auth/me',
        data=json.dumps({
            'password': 'newpassword123'
        }),
        headers=combined_headers
    )
    
    assert response.status_code == 200
    assert json.loads(response.data)['message'] == 'User updated successfully'
    
    # Verify password was updated
    with app.app_context():
        from app.models.user import User
        user = User.query.get(user_id)
        assert user.check_password('newpassword123')
        assert not user.check_password('password123')
    
    # Test unique constraint violations
    # First create another user
    client.post(
        '/api/v1/auth/register',
        data=json.dumps({
            'username': 'anotheruser',
            'email': 'another@example.com',
            'password': 'password123'
        }),
        headers=json_content_headers
    )
    
    # Try to update to existing username
    response = client.put(
        '/api/v1/auth/me',
        data=json.dumps({
            'username': 'anotheruser'
        }),
        headers=combined_headers
    )
    
    assert response.status_code == 409
    assert json.loads(response.data)['error'] == 'Username already taken'
    
    # Try to update to existing email
    response = client.put(
        '/api/v1/auth/me',
        data=json.dumps({
            'email': 'another@example.com'
        }),
        headers=combined_headers
    )
    
    assert response.status_code == 409
    assert json.loads(response.data)['error'] == 'Email already taken'

### File: C:\Users\rdjon\task-management-api\tests\integration\test_comments.py
import json
import pytest

def test_get_task_comments(client, app, regular_user, test_tasks, test_comments, auth_headers):
    """Test getting all comments for a task."""
    # Ensure objects are attached to session and store expected values
    with app.app_context():
        from app import db
        user = db.session.merge(regular_user)
        task = db.session.merge(test_tasks[0])
        comment = db.session.merge(test_comments[0])
        
        task_id = task.id
        expected_user_id = user.id
        expected_content = comment.content
    
    # Test successful retrieval
    response = client.get(f'/api/v1/tasks/{task_id}/comments', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert len(data) == 2
    assert data[0]['content'] == expected_content
    assert data[0]['task_id'] == task_id
    assert data[0]['user_id'] == expected_user_id
    
    # Test non-existent task
    response = client.get('/api/v1/tasks/9999/comments', headers=auth_headers)
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'Task not found'
    
    # Test without authentication
    response = client.get(f'/api/v1/tasks/{task_id}/comments')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_create_comment(client, app, regular_user, test_tasks, auth_headers, json_content_headers):
    """Test creating a comment for a task."""
    # Ensure objects are attached to session and store IDs
    with app.app_context():
        from app import db
        user = db.session.merge(regular_user)
        task = db.session.merge(test_tasks[0])
        
        user_id = user.id
        task_id = task.id
    
    combined_headers = {**auth_headers, **json_content_headers}
    
    # Test successful creation
    comment_data = {
        'content': 'This is a new comment'
    }
    
    response = client.post(
        f'/api/v1/tasks/{task_id}/comments',
        data=json.dumps(comment_data),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 201
    assert data['message'] == 'Comment created successfully'
    assert data['comment']['content'] == comment_data['content']
    assert data['comment']['task_id'] == task_id
    assert data['comment']['user_id'] == user_id
    
    # Verify in database
    with app.app_context():
        from app.models.comment import Comment
        comment = Comment.query.filter_by(content='This is a new comment').first()
        assert comment is not None
        assert comment.content == comment_data['content']
        assert comment.task_id == task_id
        assert comment.user_id == user_id
    
    # Test non-existent task
    response = client.post(
        '/api/v1/tasks/9999/comments',
        data=json.dumps(comment_data),
        headers=combined_headers
    )
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'Task not found'
    
    # Test validation errors
    invalid_comment_data = {
        'content': ''  # Empty content
    }
    
    response = client.post(
        f'/api/v1/tasks/{task_id}/comments',
        data=json.dumps(invalid_comment_data),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 400
    assert 'error' in data
    assert 'messages' in data
    assert 'content' in data['messages']
    
    # Test without authentication
    response = client.post(
        f'/api/v1/tasks/{task_id}/comments',
        data=json.dumps(comment_data),
        headers=json_content_headers
    )
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_get_comment(client, app, regular_user, test_tasks, test_comments, auth_headers):
    """Test getting a specific comment."""
    # Ensure objects are attached to session and store expected values
    with app.app_context():
        from app import db
        user = db.session.merge(regular_user)
        task = db.session.merge(test_tasks[0])
        comment = db.session.merge(test_comments[0])
        
        comment_id = comment.id
        expected_content = comment.content
        expected_task_id = task.id
        expected_user_id = user.id
    
    # Test successful retrieval
    response = client.get(f'/api/v1/comments/{comment_id}', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['id'] == comment_id
    assert data['content'] == expected_content
    assert data['task_id'] == expected_task_id
    assert data['user_id'] == expected_user_id
    
    # Test non-existent comment
    response = client.get('/api/v1/comments/9999', headers=auth_headers)
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'Comment not found'
    
    # Test without authentication
    response = client.get(f'/api/v1/comments/{comment_id}')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_update_comment(client, app, regular_user, test_comments, auth_headers, json_content_headers):
    """Test updating a comment."""
    # Ensure objects are attached to session and store IDs
    with app.app_context():
        from app import db
        comment = db.session.merge(test_comments[0])
        comment_id = comment.id
    
    combined_headers = {**auth_headers, **json_content_headers}
    
    # Test successful update
    update_data = {
        'content': 'Updated comment content'
    }
    
    response = client.put(
        f'/api/v1/comments/{comment_id}',
        data=json.dumps(update_data),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['message'] == 'Comment updated successfully'
    assert data['comment']['content'] == update_data['content']
    
    # Verify in database
    with app.app_context():
        from app.models.comment import Comment
        comment = Comment.query.get(comment_id)
        assert comment.content == update_data['content']
    
    # Test non-existent comment
    response = client.put(
        '/api/v1/comments/9999',
        data=json.dumps(update_data),
        headers=combined_headers
    )
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'Comment not found'
    
    # Test validation errors
    invalid_update_data = {
        'content': ''  # Empty content
    }
    
    response = client.put(
        f'/api/v1/comments/{comment_id}',
        data=json.dumps(invalid_update_data),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 400
    assert 'error' in data
    assert 'messages' in data
    assert 'content' in data['messages']
    
    # Test without authentication
    response = client.put(
        f'/api/v1/comments/{comment_id}',
        data=json.dumps(update_data),
        headers=json_content_headers
    )
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_delete_comment(client, app, regular_user, test_comments, auth_headers):
    """Test deleting a comment."""
    # Ensure objects are attached to session and store IDs
    with app.app_context():
        from app import db
        comments = [db.session.merge(comment) for comment in test_comments]
        comment_id_1 = comments[0].id
        comment_id_2 = comments[1].id
    
    # Test successful deletion
    response = client.delete(f'/api/v1/comments/{comment_id_1}', headers=auth_headers)
    
    assert response.status_code == 200
    assert json.loads(response.data)['message'] == 'Comment deleted successfully'
    
    # Verify in database
    with app.app_context():
        from app.models.comment import Comment
        comment = Comment.query.get(comment_id_1)
        assert comment is None
    
    # Test non-existent comment
    response = client.delete('/api/v1/comments/9999', headers=auth_headers)
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'Comment not found'
    
    # Test without authentication
    response = client.delete(f'/api/v1/comments/{comment_id_2}')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

### File: C:\Users\rdjon\task-management-api\tests\integration\test_export.py
import json
import pytest
import csv
from io import StringIO

def test_export_tasks_json(client, app, regular_user, test_tasks, auth_headers):
    """Test exporting tasks as JSON."""
    # Ensure objects are attached to session and store expected values
    with app.app_context():
        from app import db
        tasks = [db.session.merge(task) for task in test_tasks]
        
        expected_title = tasks[0].title
        expected_desc = tasks[0].description
        expected_status = tasks[0].status
        expected_priority = tasks[0].priority
    
    # Test successful export
    response = client.get('/api/v1/tasks/export?format=json', headers=auth_headers)
    
    assert response.status_code == 200
    assert response.content_type == 'application/json'
    
    data = json.loads(response.data)
    assert len(data) == 3
    
    # Verify task data
    assert data[0]['title'] == expected_title
    assert data[0]['description'] == expected_desc
    assert data[0]['status'] == expected_status
    assert data[0]['priority'] == expected_priority
    
    # Test with filters
    response = client.get('/api/v1/tasks/export?format=json&status=pending', headers=auth_headers)
    
    assert response.status_code == 200
    data = json.loads(response.data)
    
    # Check that all returned tasks have status 'pending'
    assert all(task['status'] == 'pending' for task in data)
    
    # Test without authentication
    response = client.get('/api/v1/tasks/export?format=json')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_export_tasks_csv(client, app, regular_user, test_tasks, auth_headers):
    """Test exporting tasks as CSV."""
    # Ensure objects are attached to session and store expected values
    with app.app_context():
        from app import db
        tasks = [db.session.merge(task) for task in test_tasks]
        
        expected_id = tasks[0].id
        expected_title = tasks[0].title
        expected_desc = tasks[0].description
        expected_status = tasks[0].status
        expected_priority = tasks[0].priority
    
    # Test successful export
    response = client.get('/api/v1/tasks/export?format=csv', headers=auth_headers)
    
    assert response.status_code == 200
    assert response.content_type.startswith('text/csv')
    assert 'attachment; filename=tasks.csv' in response.headers.get('Content-Disposition', '')
    
    # Parse CSV response
    csv_data = csv.reader(StringIO(response.data.decode('utf-8')))
    rows = list(csv_data)
    
    # Check header row
    header = rows[0]
    assert 'ID' in header
    assert 'Title' in header
    assert 'Description' in header
    assert 'Status' in header
    assert 'Priority' in header
    assert 'Due Date' in header
    
    # Check data rows
    assert len(rows) == 4  # Header + 3 tasks
    
    # Check the data in the first row
    data_row = rows[1]
    assert int(data_row[0]) == expected_id
    assert data_row[1] == expected_title
    assert data_row[2] == expected_desc
    assert data_row[3] == expected_status
    assert data_row[4] == expected_priority
    
    # Test with filters
    response = client.get('/api/v1/tasks/export?format=csv&status=pending', headers=auth_headers)
    
    assert response.status_code == 200
    csv_data = csv.reader(StringIO(response.data.decode('utf-8')))
    rows = list(csv_data)
    
    # Check that all returned tasks have status 'pending' (skipping header row)
    assert all(row[3] == 'pending' for row in rows[1:])
    
    # Test without authentication
    response = client.get('/api/v1/tasks/export?format=csv')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_export_invalid_format(client, auth_headers):
    """Test exporting tasks with invalid format."""
    response = client.get('/api/v1/tasks/export?format=invalid', headers=auth_headers)
    
    assert response.status_code == 400
    assert json.loads(response.data)['error'] == 'Unsupported export format'

### File: C:\Users\rdjon\task-management-api\tests\integration\test_tags.py
import json
import pytest

def test_get_tags(client, app, regular_user, test_tags, auth_headers):
    """Test getting all tags."""
    # Ensure objects are attached to session and store expected values
    with app.app_context():
        from app import db
        user = db.session.merge(regular_user)
        tags = [db.session.merge(tag) for tag in test_tags]
        expected_user_id = user.id
        expected_tag_name = tags[0].name
        expected_tag_color = tags[0].color
    
    # Test successful retrieval
    response = client.get('/api/v1/tags', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert len(data) == 3
    assert data[0]['name'] == expected_tag_name
    assert data[0]['color'] == expected_tag_color
    assert data[0]['user_id'] == expected_user_id
    
    # Test without authentication
    response = client.get('/api/v1/tags')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_get_tag(client, app, regular_user, test_tags, auth_headers):
    """Test getting a specific tag."""
    # Ensure objects are attached to session and store expected values
    with app.app_context():
        from app import db
        user = db.session.merge(regular_user)
        tag = db.session.merge(test_tags[0])
        tag_id = tag.id
        expected_name = tag.name
        expected_color = tag.color
        expected_user_id = user.id
    
    # Test successful retrieval
    response = client.get(f'/api/v1/tags/{tag_id}', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['id'] == tag_id
    assert data['name'] == expected_name
    assert data['color'] == expected_color
    assert data['user_id'] == expected_user_id
    
    # Test non-existent tag
    response = client.get('/api/v1/tags/9999', headers=auth_headers)
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'Tag not found'
    
    # Test without authentication
    response = client.get(f'/api/v1/tags/{tag_id}')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_create_tag(client, app, regular_user, auth_headers, json_content_headers):
    """Test creating a tag."""
    # Ensure user is attached to session and store ID
    with app.app_context():
        from app import db
        user = db.session.merge(regular_user)
        user_id = user.id
    
    combined_headers = {**auth_headers, **json_content_headers}
    
    # Test successful creation
    tag_data = {
        'name': 'New Tag',
        'color': '#ff00ff'
    }
    
    response = client.post(
        '/api/v1/tags',
        data=json.dumps(tag_data),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 201
    assert data['message'] == 'Tag created successfully'
    assert data['tag']['name'] == tag_data['name']
    assert data['tag']['color'] == tag_data['color']
    assert data['tag']['user_id'] == user_id
    
    # Verify in database
    with app.app_context():
        from app.models.tag import Tag
        tag = Tag.query.filter_by(name='New Tag').first()
        assert tag is not None
        assert tag.name == tag_data['name']
        assert tag.color == tag_data['color']
        assert tag.user_id == user_id
    
    # Test with default color
    minimal_tag_data = {
        'name': 'Minimal Tag'
    }
    
    response = client.post(
        '/api/v1/tags',
        data=json.dumps(minimal_tag_data),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 201
    assert data['tag']['name'] == minimal_tag_data['name']
    assert data['tag']['color'] == '#3498db'  # Default color
    
    # Test duplicate tag name
    duplicate_tag_data = {
        'name': 'New Tag'  # Same as first tag
    }
    
    response = client.post(
        '/api/v1/tags',
        data=json.dumps(duplicate_tag_data),
        headers=combined_headers
    )
    
    assert response.status_code == 409
    assert json.loads(response.data)['error'] == 'Tag with this name already exists'
    
    # Test validation errors
    invalid_tag_data = {
        'name': '',  # Empty name
        'color': 'invalid-color'  # Invalid color format
    }
    
    response = client.post(
        '/api/v1/tags',
        data=json.dumps(invalid_tag_data),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 400
    assert 'error' in data
    assert 'messages' in data
    assert 'name' in data['messages']
    assert 'color' in data['messages']
    
    # Test without authentication
    response = client.post(
        '/api/v1/tags',
        data=json.dumps(tag_data),
        headers=json_content_headers
    )
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_update_tag(client, app, regular_user, test_tags, auth_headers, json_content_headers):
    """Test updating a tag."""
    # Ensure objects are attached to session and store expected values
    with app.app_context():
        from app import db
        tags = [db.session.merge(tag) for tag in test_tags]
        tag_id = tags[0].id
        other_tag_name = tags[1].name
    
    combined_headers = {**auth_headers, **json_content_headers}
    
    # Test successful update
    update_data = {
        'name': 'Updated Tag',
        'color': '#00ffff'
    }
    
    response = client.put(
        f'/api/v1/tags/{tag_id}',
        data=json.dumps(update_data),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['message'] == 'Tag updated successfully'
    assert data['tag']['name'] == update_data['name']
    assert data['tag']['color'] == update_data['color']
    
    # Verify in database
    with app.app_context():
        from app.models.tag import Tag
        tag = Tag.query.get(tag_id)
        assert tag.name == update_data['name']
        assert tag.color == update_data['color']
    
    # Test partial update
    partial_update = {
        'color': '#ffff00'
    }
    
    response = client.put(
        f'/api/v1/tags/{tag_id}',
        data=json.dumps(partial_update),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['tag']['name'] == update_data['name']  # Unchanged
    assert data['tag']['color'] == partial_update['color']
    
    # Test conflict with existing tag name
    conflict_update = {
        'name': other_tag_name  # Name of another tag
    }
    
    response = client.put(
        f'/api/v1/tags/{tag_id}',
        data=json.dumps(conflict_update),
        headers=combined_headers
    )
    
    assert response.status_code == 409
    assert json.loads(response.data)['error'] == 'Tag with this name already exists'
    
    # Test non-existent tag
    response = client.put(
        '/api/v1/tags/9999',
        data=json.dumps(update_data),
        headers=combined_headers
    )
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'Tag not found'
    
    # Test without authentication
    response = client.put(
        f'/api/v1/tags/{tag_id}',
        data=json.dumps(update_data),
        headers=json_content_headers
    )
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_delete_tag(client, app, regular_user, test_tags, auth_headers):
    """Test deleting a tag."""
    # Ensure tags are attached to session and store IDs
    with app.app_context():
        from app import db
        tags = [db.session.merge(tag) for tag in test_tags]
        tag_id_1 = tags[0].id
        tag_id_2 = tags[1].id
    
    # Test successful deletion
    response = client.delete(f'/api/v1/tags/{tag_id_1}', headers=auth_headers)
    
    assert response.status_code == 200
    assert json.loads(response.data)['message'] == 'Tag deleted successfully'
    
    # Verify in database
    with app.app_context():
        from app.models.tag import Tag
        tag = Tag.query.get(tag_id_1)
        assert tag is None
    
    # Test non-existent tag
    response = client.delete('/api/v1/tags/9999', headers=auth_headers)
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'Tag not found'
    
    # Test without authentication
    response = client.delete(f'/api/v1/tags/{tag_id_2}')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_task_tag_relationships(client, app, regular_user, test_tasks, test_tags, auth_headers, json_content_headers):
    """Test tag-task relationships."""
    # Ensure objects are attached to session and store IDs
    with app.app_context():
        from app import db
        tasks = [db.session.merge(task) for task in test_tasks]
        tags = [db.session.merge(tag) for tag in test_tags]
        task_id = tasks[0].id
        tag_id = tags[0].id
    
    combined_headers = {**auth_headers, **json_content_headers}
    
    # Test adding tag to task
    tag_data = {
        'tag_id': tag_id
    }
    
    response = client.post(
        f'/api/v1/tasks/{task_id}/tags',
        data=json.dumps(tag_data),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['message'] == 'Tag added to task successfully'
    assert len(data['task']['tags']) == 1
    assert data['task']['tags'][0]['id'] == tag_id
    
    # Verify in database
    with app.app_context():
        from app.models.task import Task
        from app.models.tag import Tag
        task = Task.query.get(task_id)
        tag = Tag.query.get(tag_id)
        assert tag in task.tags
    
    # Test filtering tasks by tag
    response = client.get(f'/api/v1/tasks?tag={tag_id}', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert len(data['tasks']) == 1
    assert data['tasks'][0]['id'] == task_id
    
    # Test removing tag from task
    response = client.delete(
        f'/api/v1/tasks/{task_id}/tags/{tag_id}',
        headers=auth_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['message'] == 'Tag removed from task successfully'
    assert len(data['task']['tags']) == 0
    
    # Verify in database
    with app.app_context():
        from app.models.task import Task
        from app.models.tag import Tag
        task = Task.query.get(task_id)
        tag = Tag.query.get(tag_id)
        assert tag not in task.tags

### File: C:\Users\rdjon\task-management-api\tests\integration\test_tasks.py
import json
import pytest
from datetime import datetime, timedelta

def test_get_tasks(client, app, regular_user, test_tasks, auth_headers):
    """Test getting all tasks."""
    # Test successful retrieval
    response = client.get('/api/v1/tasks', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert 'tasks' in data
    assert len(data['tasks']) == 3
    assert data['total'] == 3
    assert data['page'] == 1
    assert data['per_page'] == 10
    
    # Test with pagination
    response = client.get('/api/v1/tasks?page=1&per_page=2', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert len(data['tasks']) == 2
    assert data['total'] == 3
    assert data['pages'] == 2
    assert data['page'] == 1
    assert data['per_page'] == 2
    
    # Test with status filter
    response = client.get('/api/v1/tasks?status=pending', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert len(data['tasks']) == 1
    assert data['tasks'][0]['status'] == 'pending'
    
    # Test with priority filter
    response = client.get('/api/v1/tasks?priority=high', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert len(data['tasks']) == 1
    assert data['tasks'][0]['priority'] == 'high'
    
    # Test with search
    response = client.get('/api/v1/tasks?search=Test Task 1', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert len(data['tasks']) == 1
    assert 'Test Task 1' in data['tasks'][0]['title']
    
    # Test with sorting
    response = client.get('/api/v1/tasks?sort_by=title&sort_order=asc', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert len(data['tasks']) == 3
    assert data['tasks'][0]['title'] < data['tasks'][1]['title']
    assert data['tasks'][1]['title'] < data['tasks'][2]['title']
    
    # Test without authentication
    response = client.get('/api/v1/tasks')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_get_task(client, app, regular_user, test_tasks, auth_headers):
    """Test getting a specific task."""
    # Get task ID safely
    with app.app_context():
        from app import db
        task = db.session.merge(test_tasks[0])
        task_id = task.id
        expected_title = task.title
        expected_description = task.description
        expected_status = task.status
        expected_priority = task.priority
    
    # Test successful retrieval
    response = client.get(f'/api/v1/tasks/{task_id}', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['id'] == task_id
    assert data['title'] == expected_title
    assert data['description'] == expected_description
    assert data['status'] == expected_status
    assert data['priority'] == expected_priority
    
    # Test non-existent task
    response = client.get(f'/api/v1/tasks/9999', headers=auth_headers)
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'Task not found'
    
    # Test without authentication
    response = client.get(f'/api/v1/tasks/{task_id}')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_create_task(client, app, regular_user, auth_headers, json_content_headers):
    """Test creating a task."""
    # Get user ID safely
    with app.app_context():
        from app import db
        user = db.session.merge(regular_user)
        user_id = user.id
    
    combined_headers = {**auth_headers, **json_content_headers}
    
    # Test successful creation
    task_data = {
        'title': 'New Test Task',
        'description': 'Description for New Test Task',
        'status': 'pending',
        'priority': 'high',
        'due_date': (datetime.utcnow() + timedelta(days=1)).isoformat()
    }
    
    response = client.post(
        '/api/v1/tasks',
        data=json.dumps(task_data),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 201
    assert data['message'] == 'Task created successfully'
    assert data['task']['title'] == task_data['title']
    assert data['task']['description'] == task_data['description']
    assert data['task']['status'] == task_data['status']
    assert data['task']['priority'] == task_data['priority']
    
    # Verify in database
    with app.app_context():
        from app.models.task import Task
        task = Task.query.filter_by(title='New Test Task').first()
        assert task is not None
        assert task.title == task_data['title']
        assert task.description == task_data['description']
        assert task.status == task_data['status']
        assert task.priority == task_data['priority']
        assert task.user_id == user_id
    
    # Test with minimum required fields
    minimal_task_data = {
        'title': 'Minimal Task'
    }
    
    response = client.post(
        '/api/v1/tasks',
        data=json.dumps(minimal_task_data),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 201
    assert data['task']['title'] == minimal_task_data['title']
    assert data['task']['status'] == 'pending'  # Default value
    assert data['task']['priority'] == 'medium'  # Default value
    
    # Test validation errors
    invalid_task_data = {
        'title': '',  # Empty title
        'status': 'invalid_status',  # Invalid status
        'priority': 'invalid_priority',  # Invalid priority
        'due_date': 'invalid_date'  # Invalid date format
    }
    
    response = client.post(
        '/api/v1/tasks',
        data=json.dumps(invalid_task_data),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 400
    assert 'error' in data
    assert 'messages' in data
    assert 'title' in data['messages']
    assert 'status' in data['messages']
    assert 'priority' in data['messages']
    assert 'due_date' in data['messages']
    
    # Test without authentication
    response = client.post(
        '/api/v1/tasks',
        data=json.dumps(task_data),
        headers=json_content_headers
    )
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_update_task(client, app, regular_user, test_tasks, auth_headers, json_content_headers):
    """Test updating a task."""
    # Get task ID safely
    with app.app_context():
        from app import db
        task = db.session.merge(test_tasks[0])
        task_id = task.id
    
    combined_headers = {**auth_headers, **json_content_headers}
    
    # Test successful update
    update_data = {
        'title': 'Updated Test Task',
        'description': 'Updated Description',
        'status': 'in_progress',
        'priority': 'low'
    }
    
    response = client.put(
        f'/api/v1/tasks/{task_id}',
        data=json.dumps(update_data),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['message'] == 'Task updated successfully'
    assert data['task']['title'] == update_data['title']
    assert data['task']['description'] == update_data['description']
    assert data['task']['status'] == update_data['status']
    assert data['task']['priority'] == update_data['priority']
    
    # Verify in database
    with app.app_context():
        from app.models.task import Task
        task = Task.query.get(task_id)
        assert task.title == update_data['title']
        assert task.description == update_data['description']
        assert task.status == update_data['status']
        assert task.priority == update_data['priority']
    
    # Test partial update
    partial_update = {
        'title': 'Partially Updated Task'
    }
    
    response = client.put(
        f'/api/v1/tasks/{task_id}',
        data=json.dumps(partial_update),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert data['task']['title'] == partial_update['title']
    assert data['task']['description'] == update_data['description']  # Unchanged
    assert data['task']['status'] == update_data['status']  # Unchanged
    assert data['task']['priority'] == update_data['priority']  # Unchanged
    
    # Test non-existent task
    response = client.put(
        '/api/v1/tasks/9999',
        data=json.dumps(update_data),
        headers=combined_headers
    )
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'Task not found'
    
    # Test validation errors
    invalid_update = {
        'status': 'invalid_status',
        'priority': 'invalid_priority'
    }
    
    response = client.put(
        f'/api/v1/tasks/{task_id}',
        data=json.dumps(invalid_update),
        headers=combined_headers
    )
    
    data = json.loads(response.data)
    
    assert response.status_code == 400
    assert 'error' in data
    assert 'messages' in data
    assert 'status' in data['messages']
    assert 'priority' in data['messages']
    
    # Test without authentication
    response = client.put(
        f'/api/v1/tasks/{task_id}',
        data=json.dumps(update_data),
        headers=json_content_headers
    )
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_delete_task(client, app, regular_user, test_tasks, auth_headers):
    """Test deleting a task."""
    # Get task IDs safely
    with app.app_context():
        from app import db
        tasks = [db.session.merge(task) for task in test_tasks]
        task_id_1 = tasks[0].id
        task_id_2 = tasks[1].id
    
    # Test successful deletion
    response = client.delete(f'/api/v1/tasks/{task_id_1}', headers=auth_headers)
    
    assert response.status_code == 200
    assert json.loads(response.data)['message'] == 'Task deleted successfully'
    
    # Verify in database
    with app.app_context():
        from app.models.task import Task
        task = Task.query.get(task_id_1)
        assert task is None
    
    # Test non-existent task
    response = client.delete(f'/api/v1/tasks/9999', headers=auth_headers)
    
    assert response.status_code == 404
    assert json.loads(response.data)['error'] == 'Task not found'
    
    # Test without authentication
    response = client.delete(f'/api/v1/tasks/{task_id_2}')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_task_statistics(client, app, regular_user, test_tasks, auth_headers):
    """Test getting task statistics."""
    # Ensure test_tasks are attached to the session
    with app.app_context():
        from app import db
        # Just merge one task to ensure it's attached - we're not using its properties directly
        db.session.merge(test_tasks[0])
    
    # Test successful retrieval
    response = client.get('/api/v1/tasks/statistics', headers=auth_headers)
    
    data = json.loads(response.data)
    
    assert response.status_code == 200
    assert 'total_tasks' in data
    assert data['total_tasks'] == 3
    assert 'by_status' in data
    assert 'pending' in data['by_status']
    assert 'in_progress' in data['by_status']
    assert 'completed' in data['by_status']
    assert 'by_priority' in data
    assert 'high' in data['by_priority']
    assert 'medium' in data['by_priority']
    assert 'low' in data['by_priority']
    
    # Test without authentication
    response = client.get('/api/v1/tasks/statistics')
    
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Authorization required'

def test_bulk_actions(client, app, regular_user, test_tasks, auth_headers, json_content_headers):
    """Test bulk actions on tasks."""
    # Get task IDs safely
    with app.app_context():
        from app import db
        tasks = [db.session.merge(task) for task in test_tasks]
        task_ids = [task.id for task in tasks]
    
    combined_headers = {**auth_headers, **json_content_headers}
    
    # Test bulk update
    bulk_update_data = {
        'task_ids': task_ids,
        'updates': {
            'status': 'in_progress',
            'priority': 'high'
        }
    }
    
    response = client.put(
        '/api/v1/tasks/bulk/update',
        data=json.dumps(bulk_update_data),
        headers=combined_headers
    )
    
    assert response.status_code == 200
    assert json.loads(response.data)['message'] == f"{len(task_ids)} tasks updated successfully"
    
    # Verify in database
    with app.app_context():
        from app.models.task import Task
        for task_id in task_ids:
            task = Task.query.get(task_id)
            assert task.status == 'in_progress'
            assert task.priority == 'high'
    
    # Test bulk delete
    bulk_delete_data = {
        'task_ids': task_ids[:2]  # Delete first two tasks
    }
    
    response = client.post(
        '/api/v1/tasks/bulk/delete',
        data=json.dumps(bulk_delete_data),
        headers=combined_headers
    )
    
    assert response.status_code == 200
    assert json.loads(response.data)['message'] == f"{len(bulk_delete_data['task_ids'])} tasks deleted successfully"
    
    # Verify in database
    with app.app_context():
        from app.models.task import Task
        for task_id in bulk_delete_data['task_ids']:
            task = Task.query.get(task_id)
            assert task is None
        
        # The third task should still exist
        task = Task.query.get(task_ids[2])
        assert task is not None
    
    # Test validation errors
    invalid_bulk_update = {
        'task_ids': [],  # Empty list
        'updates': {
            'status': 'invalid_status'  # Invalid status
        }
    }
    
    response = client.put(
        '/api/v1/tasks/bulk/update',
        data=json.dumps(invalid_bulk_update),
        headers=combined_headers
    )
    
    assert response.status_code == 400
    assert 'error' in json.loads(response.data)

### File: C:\Users\rdjon\task-management-api\tests\integration\__init__.py


### File: C:\Users\rdjon\task-management-api\tests\unit\test_models.py
from datetime import datetime, timedelta
from app.models.user import User
from app.models.task import Task
from app.models.tag import Tag
from app.models.comment import Comment
from app.models.token_blacklist import TokenBlacklist

def test_user_model(app):
    """Test User model."""
    with app.app_context():
        # Test user creation
        user = User(
            username="testuser",
            email="test@example.com",
            password="password123"
        )
        
        assert user.username == "testuser"
        assert user.email == "test@example.com"
        assert user.role == "user"  # Default role
        assert user.check_password("password123")
        assert not user.check_password("wrongpassword")
        
        # Test admin role
        admin = User(
            username="admin",
            email="admin@example.com",
            password="adminpass",
            role="admin"
        )
        
        assert admin.role == "admin"
        assert admin.is_admin()
        assert not user.is_admin()
        
        # Test to_dict method
        user_dict = user.to_dict()
        assert user_dict['username'] == "testuser"
        assert user_dict['email'] == "test@example.com"
        assert user_dict['role'] == "user"
        assert 'password_hash' not in user_dict  # Should not expose password hash

def test_task_model(app, regular_user):
    """Test Task model."""
    with app.app_context():
        # Ensure the user is attached to the current session
        from app import db
        user = db.session.merge(regular_user)
        
        # Test task creation
        task = Task(
            title="Test Task",
            description="This is a test task",
            status="pending",
            priority="high",
            due_date=datetime.utcnow() + timedelta(days=1),
            user_id=user.id
        )
        
        assert task.title == "Test Task"
        assert task.description == "This is a test task"
        assert task.status == "pending"
        assert task.priority == "high"
        assert task.user_id == user.id
        assert task.due_date is not None
        
        # Test default values
        simple_task = Task(
            title="Simple Task",
            user_id=user.id
        )
        
        assert simple_task.status == "pending"  # Default status
        assert simple_task.priority == "medium"  # Default priority
        assert simple_task.description is None
        assert simple_task.due_date is None
        
        # Test to_dict method
        task_dict = task.to_dict()
        assert task_dict['title'] == "Test Task"
        assert task_dict['description'] == "This is a test task"
        assert task_dict['status'] == "pending"
        assert task_dict['priority'] == "high"
        assert task_dict['user_id'] == user.id
        assert 'due_date' in task_dict
        assert 'created_at' in task_dict
        assert 'updated_at' in task_dict

def test_tag_model(app, regular_user):
    """Test Tag model."""
    with app.app_context():
        # Ensure the user is attached to the current session
        from app import db
        user = db.session.merge(regular_user)
        
        # Test tag creation
        tag = Tag(
            name="Work",
            color="#ff5500",
            user_id=user.id
        )
        
        assert tag.name == "Work"
        assert tag.color == "#ff5500"
        assert tag.user_id == user.id
        
        # Test default color
        simple_tag = Tag(
            name="Simple",
            user_id=user.id
        )
        
        assert simple_tag.color == "#3498db"  # Default color
        
        # Test to_dict method
        tag_dict = tag.to_dict()
        assert tag_dict['name'] == "Work"
        assert tag_dict['color'] == "#ff5500"
        assert tag_dict['user_id'] == user.id

def test_comment_model(app, regular_user, test_tasks):
    """Test Comment model."""
    with app.app_context():
        # Ensure objects are attached to the current session
        from app import db
        user = db.session.merge(regular_user)
        tasks = [db.session.merge(task) for task in test_tasks]
        
        # Test comment creation
        comment = Comment(
            content="This is a test comment",
            task_id=tasks[0].id,
            user_id=user.id
        )
        
        assert comment.content == "This is a test comment"
        assert comment.task_id == tasks[0].id
        assert comment.user_id == user.id
        
        # Test to_dict method
        comment_dict = comment.to_dict()
        assert comment_dict['content'] == "This is a test comment"
        assert comment_dict['task_id'] == tasks[0].id
        assert comment_dict['user_id'] == user.id
        assert 'created_at' in comment_dict
        assert 'updated_at' in comment_dict

def test_token_blacklist_model(app, regular_user):
    """Test TokenBlacklist model."""
    with app.app_context():
        # Ensure the user is attached to the current session
        from app import db
        user = db.session.merge(regular_user)
        
        # Test token blacklist creation
        expires_at = datetime.utcnow() + timedelta(hours=1)
        token_blacklist = TokenBlacklist(
            jti="test-jti-123",
            token_type="access",
            user_id=user.id,
            expires_at=expires_at
        )
        
        assert token_blacklist.jti == "test-jti-123"
        assert token_blacklist.token_type == "access"
        assert token_blacklist.user_id == user.id
        assert token_blacklist.expires_at == expires_at
        
        # Test is_token_revoked class method
        jwt_payload = {"jti": "test-jti-123"}
        
        # Token not in database yet
        assert not TokenBlacklist.is_token_revoked(jwt_payload)
        
        # Add token to database
        db.session.add(token_blacklist)
        db.session.commit()
        
        # Now token should be revoked
        assert TokenBlacklist.is_token_revoked(jwt_payload)

def test_relationships(app, regular_user, test_tasks, test_tags, test_comments):
    """Test model relationships."""
    with app.app_context():
        # Ensure all objects are attached to the current session
        from app import db
        user = db.session.merge(regular_user)
        tasks = [db.session.merge(task) for task in test_tasks]
        tags = [db.session.merge(tag) for tag in test_tags]
        comments = [db.session.merge(comment) for comment in test_comments]
        
        # Test User-Task relationship
        user = User.query.get(user.id)
        assert len(user.tasks) == 3
        assert user.tasks[0].title == tasks[0].title
        
        # Test User-Tag relationship
        assert len(user.tags) == 3
        assert user.tags[0].name == tags[0].name
        
        # Test User-Comment relationship
        assert len(user.comments) == 2
        assert user.comments[0].content == comments[0].content
        
        # Test Task-Comment relationship
        task = Task.query.get(tasks[0].id)
        assert len(task.comments) == 2
        assert task.comments[0].content == comments[0].content
        
        # Test Tag-Task relationship
        # First add a tag to a task
        task.tags.append(tags[0])
        db.session.commit()
        
        # Refresh tag from database
        tag = Tag.query.get(tags[0].id)
        
        # Check relationship
        assert task in tag.tasks
        assert tag in task.tags

### File: C:\Users\rdjon\task-management-api\tests\unit\__init__.py


